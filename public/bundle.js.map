{"version":3,"file":"bundle.js","mappings":";;;;;;;;;;;;;;AAAe;AACf;AACA;AACA,2BAA2B,OAAO;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,sBAAsB;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;AC1DuC;AACxB;AACf;AACA;AACA,sDAAsD;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,qCAAqC;AACnD,cAAc,4DAA4D;AAC1E,cAAc,iEAAiE;AAC/E,cAAc,2DAA2D;AACzE,cAAc,sCAAsC;AACpD,cAAc,0DAA0D;AACxE,cAAc,+DAA+D;AAC7E,cAAc,yDAAyD;AACvE,cAAc,2CAA2C;AACzD,cAAc,iEAAiE;AAC/E,cAAc,4CAA4C;AAC1D,cAAc;AACd;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,cAAc,qCAAqC;AACnD,cAAc,yDAAyD;AACvE,cAAc,8DAA8D;AAC5E,cAAc,wDAAwD;AACtE,cAAc,sCAAsC;AACpD,cAAc,6DAA6D;AAC3E,cAAc,kEAAkE;AAChF,cAAc,4DAA4D;AAC1E,cAAc,2CAA2C;AACzD,cAAc,8DAA8D;AAC5E,cAAc,4CAA4C;AAC1D,cAAc;AACd;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,gBAAgB,mEAAa,wBAAwB,MAAM,YAAY,EAAE,8BAA8B,EAAE,sBAAsB;AAC9J;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;AClI2B;AACiB;AACE;AAC/B,iCAAiC,uDAAc;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,oBAAoB,kDAAS;AAC7B,sBAAsB,mEAAiB;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,6DAA6D,kDAAS;AACtE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,IAAI,qDAAqD,OAAO;AAC/E;AACA,+CAA+C,KAAK;AACpD;AACA;AACA,aAAa;AACb;AACA;AACA;;;;;;;;;;;;;;;;AClE8C;AAC/B,iCAAiC,uDAAc;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;ACzB2B;AACQ;AACR;AACZ;AACf;AACA;AACA;AACA;AACA,yBAAyB,oDAAK;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,kDAAS;AACrB;AACA;AACA,YAAY,0DAAiB;AAC7B;AACA;AACA;AACA,oDAAoD,kDAAS;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,4BAA4B,4DAAmB;AAC/C;AACA;AACA;AACA,YAAY,4DAAmB;AAC/B;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;;;;;;;;;;;;;;;AC1De;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;AChB+B;AACkB;AACnB;AACf,+BAA+B,+CAAM;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,kDAAS,CAAC,0DAAW;AAC9C,UAAU;AACV;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;ACjB+B;AACQ;AACwD;AACjE;AACf,6BAA6B,+CAAM;AAClD;AACA;AACA;AACA;AACA;AACA,oBAAoB,kDAAS,CAAC,gDAAM;AACpC,wBAAwB,kDAAS;AACjC;AACA,wBAAwB,0DAAiB,CAAC,sDAAU;AACpD;AACA,oBAAoB,0DAAiB,CAAC,0DAAc;AACpD,oBAAoB,0DAAiB,CAAC,0DAAc;AACpD,qDAAqD,kDAAS;AAC9D;AACA,iCAAiC,0DAAc;AAC/C;AACA;AACA,kBAAkB,0DAAiB;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,0DAAc;AAC/C;AACA;AACA;AACA,qCAAqC,0DAAc;AACnD;AACA;AACA,8BAA8B,kDAAS;AACvC;AACA,sBAAsB,0DAAiB,CAAC,mDAAO;AAC/C;AACA,4BAA4B;AAC5B;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;AC/C8B;AACwB;AACvB;AACxB;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,8BAA8B;AAChB,6BAA6B,+CAAM;AAClD;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C,kDAAS;AACnD;AACA;AACA;AACA;AACA;AACA,YAAY,kDAAS;AACrB;AACA,+BAA+B,oEAAe;AAC9C;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;ACnC8B;AACC;AACgC;AAChD,8BAA8B,+CAAM;AACnD;AACA;AACA;AACA;AACA;AACA,0BAA0B,yDAAU;AACpC;AACA,qCAAqC,EAAE,0DAAiB;AACxD,6BAA6B,4DAAa;AAC1C;AACA;AACA;AACA,qBAAqB,0DAAiB;AACtC,0BAA0B;AAC1B,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;AC3B+B;AACD;AACA;AACwB;AACE;AACjD;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,8BAA8B;AAChB,2BAA2B,+CAAM;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,qDAAY;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,wDAAY;AACjC;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,wDAAY;AACjC;AACA;AACA;AACA;AACA,mDAAmD,4DAAgB;AACnE;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,gDAAgD,8DAAS;AACzD;AACA;AACA,4BAA4B,qDAAY;AACxC;AACA,4BAA4B,kDAAS;AACrC,kCAAkC,yDAAgB;AAClD,iCAAiC,kDAAS;AAC1C,kCAAkC,yDAAgB;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;ACvE+B;AACD;AACA;AACwB;AACM;AACrD;AACP;AACA;AACA;AACA;AACA,CAAC,kCAAkC;AAC5B;AACP;AACA;AACA;AACA,CAAC,4BAA4B;AACd,4BAA4B,+CAAM;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qEAAqE,oEAAe;AACpF;AACA,gBAAgB,kDAAS;AACzB;AACA,0EAA0E,oEAAe;AACzF;AACA,gBAAgB,kDAAS;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,kDAAS;AACrC;AACA;AACA;AACA,4DAA4D,6DAAM,0BAA0B,6DAAM;AAClG,4DAA4D,6DAAM,0BAA0B,6DAAM;AAClG;AACA;AACA;AACA,wBAAwB,OAAO;AAC/B,8BAA8B,kDAAS;AACvC;AACA,yBAAyB,yDAAgB;AACzC;AACA;AACA,gBAAgB,kDAAS;AACzB;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;AC/D8B;AACC;AAC2C;AAC3D,iCAAiC,+CAAM;AACtD;AACA;AACA;AACA;AACA,yBAAyB,kDAAS,CAAC,0DAAS;AAC5C,yBAAyB,kDAAS,CAAC,2DAAU;AAC7C,0BAA0B,kDAAS,CAAC,4DAAW;AAC/C;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;ACf8B;AACA;AACwC;AACvC;AACY;AACA;AACqD;AACjF,2BAA2B,+CAAM;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,wDAAY;AAC7B,6BAA6B,qDAAY;AACzC;AACA,iBAAiB,wDAAY;AAC7B,6BAA6B,qDAAY;AACzC;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,gBAAgB;AACxC;AACA;AACA;AACA;AACA;AACA,0EAA0E,8DAAmB;AAC7F;AACA,sEAAsE,0DAAe;AACrF;AACA,gDAAgD,8DAAS,gBAAgB,mFAAkC;AAC3G;AACA;AACA,qCAAqC,kDAAS;AAC9C;AACA,cAAc,kDAAS;AACvB;AACA,QAAQ,yDAAgB;AACxB;AACA;AACA,cAAc,kDAAS;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,2DAAY;AACrC;AACA,4BAA4B,mEAAoB;AAChD;AACA;AACA,uBAAuB,0DAAiB;AACxC,yBAAyB,0DAAiB;AAC1C,0BAA0B;AAC1B,UAAU;AACV;AACA;AACA;AACA;AACA,+BAA+B,qDAAY;AAC3C,wBAAwB,oBAAoB;AAC5C,4CAA4C,kDAAS;AACrD;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,kDAAS;AACrC,qCAAqC,0DAAiB,CAAC,gEAAiB;AACxE,4BAA4B,kDAAS;AACrC,qCAAqC,0DAAiB,CAAC,gEAAiB;AACxE,sBAAsB;AACtB;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wDAAwD;AACxD,gBAAgB,kDAAS;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,2DAAkB;AAC9B,YAAY,6DAAoB;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;ACnI+B;AACD;AACvB;AACP;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,oBAAoB;AACN,yBAAyB,+CAAM;AAC9C;AACA;AACA;AACA;AACA,oBAAoB,kDAAS;AAC7B;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;ACrByD;AACM;AACU;AACV;AACF;AACA;AACE;AACI;AACF;AAClD;AACf;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,qEAAU;AAClC,4BAA4B,uEAAc;AAC1C,gCAAgC,6EAAkB;AAClD,2BAA2B,wEAAa;AACxC,0BAA0B,uEAAY;AACtC,0BAA0B,uEAAY;AACtC,4BAA4B,uEAAc;AAC1C,8BAA8B,yEAAgB;AAC9C,6BAA6B,wEAAe;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,UAAU;AAC1C;AACA;AACA;;;;;;;;;;;;;;;AC/Ce;AACf;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;UCJA;UACA;;UAEA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;;UAEA;UACA;;UAEA;UACA;UACA;;;;;WCtBA;WACA;WACA;WACA;WACA,yCAAyC,wCAAwC;WACjF;WACA;WACA;;;;;WCPA;;;;;WCAA;WACA;WACA;WACA,uDAAuD,iBAAiB;WACxE;WACA,gDAAgD,aAAa;WAC7D;;;;;;;;;;;;;ACNA;AACA;AACA;AACkE;AACA;AAClE;AACA;AACA;AACA;AACA;AACA,qBAAqB,uEAAkB;AACvC;AACA;AACA;AACA,qBAAqB,uEAAkB;AACvC","sources":["webpack://ts-webpack/./src/Rand.ts","webpack://ts-webpack/./src/Util.ts","webpack://ts-webpack/./src/controllers/HomePageController.ts","webpack://ts-webpack/./src/controllers/JSONPageController.ts","webpack://ts-webpack/./src/controllers/PageController.ts","webpack://ts-webpack/./src/modules/Module.ts","webpack://ts-webpack/./src/modules/general/GovernmentModule.ts","webpack://ts-webpack/./src/modules/general/HeraldryModule.ts","webpack://ts-webpack/./src/modules/general/LocationModule.ts","webpack://ts-webpack/./src/modules/general/RealmNameModule.ts","webpack://ts-webpack/./src/modules/geography/BiomesModule.ts","webpack://ts-webpack/./src/modules/geography/ClimateModule.ts","webpack://ts-webpack/./src/modules/geography/ParentEntityModule.ts","webpack://ts-webpack/./src/modules/geography/RiversModule.ts","webpack://ts-webpack/./src/modules/geography/SizeModule.ts","webpack://ts-webpack/./src/realm/Realm.ts","webpack://ts-webpack/./src/toponymy/Language.ts","webpack://ts-webpack/webpack/bootstrap","webpack://ts-webpack/webpack/runtime/define property getters","webpack://ts-webpack/webpack/runtime/hasOwnProperty shorthand","webpack://ts-webpack/webpack/runtime/make namespace object","webpack://ts-webpack/./src/index.ts"],"sourcesContent":["export default class Rand {\r\n    static generateSeed() {\r\n        // let arr: string[] = [];\r\n        // for (let i = 0; i < 3; i++) {\r\n        //   // Don't use a seeded value to generate the seed\r\n        //   arr.push(Data.words[Math.floor(Math.random() * Data.words.length)]);\r\n        // }\r\n        // Rand.seed = arr.join('-');\r\n        // Rand.seedRandomNumberGenerator();\r\n    }\r\n    static seedRandomNumberGenerator() {\r\n        let h = 1779033703 ^ Rand.seed.length;\r\n        for (var i = 0; i < Rand.seed.length; i++) {\r\n            h = Math.imul(h ^ Rand.seed.charCodeAt(i), 3432918353);\r\n            h = (h << 13) | (h >>> 19);\r\n        }\r\n        Rand.m_w = (123456789 + h) & Rand.mask;\r\n        Rand.m_z = (987654321 - h) & Rand.mask;\r\n    }\r\n    static next() {\r\n        return this.between(0, 1);\r\n    }\r\n    static between(min, max, floor = false) {\r\n        Rand.m_z = (36969 * (Rand.m_z & 65535) + (Rand.m_z >> 16)) & Rand.mask;\r\n        Rand.m_w = (18000 * (Rand.m_w & 65535) + (Rand.m_w >> 16)) & Rand.mask;\r\n        let result = ((Rand.m_z << 16) + (Rand.m_w & 65535)) >>> 0;\r\n        result /= 4294967296;\r\n        result = result * (max - min) + min;\r\n        return floor ? Math.floor(result) : result;\r\n    }\r\n    // Returns an item from an array\r\n    static pick(arr) {\r\n        return arr[Rand.between(0, arr.length, true)];\r\n    }\r\n    // Returns an item from an array\r\n    // The weight value is determined using the accessor function\r\n    // randomWeightedValue<NamePart>(nameParts, item => item.asRoot)\r\n    static weightedPick(arr, accessor, log = false) {\r\n        if (log)\r\n            console.log(arr);\r\n        // Get the max weight\r\n        const max = arr.reduce((total, item) => {\r\n            return total + accessor(item);\r\n        }, 0);\r\n        // Calculate a random number on the scale of max\r\n        let weight = Rand.between(0, max);\r\n        // For each item in the array, decrement max by that item's weight\r\n        let result;\r\n        arr.some((item) => {\r\n            weight -= accessor(item);\r\n            result = item;\r\n            return weight < 0;\r\n        });\r\n        return result;\r\n    }\r\n}\r\nRand.m_w = 123456789;\r\nRand.m_z = 987654321;\r\nRand.mask = 4294967295;\r\n","import Lang from './toponymy/Language';\r\nexport default class Util {\r\n    static download(name, text) {\r\n        var element = document.createElement('a');\r\n        element.setAttribute('href', 'data:text/plain;charset=utf-8,' + encodeURIComponent(text));\r\n        element.setAttribute('download', name);\r\n        element.style.display = 'none';\r\n        document.body.appendChild(element);\r\n        element.click();\r\n        document.body.removeChild(element);\r\n    }\r\n    static toggleDarkMode() {\r\n        Util.isDarkMode = !Util.isDarkMode;\r\n        localStorage.setItem('darkMode', JSON.stringify(Util.isDarkMode));\r\n        Util.isDarkMode ? Util.applyDarkMode() : Util.applyLightMode();\r\n    }\r\n    static applyDarkMode() {\r\n        const mode = [\r\n            { id: '--dark-text', value: '#f8f8f8' },\r\n            { id: '--dark-text-muted', value: 'rgba(248, 248, 248, 0.6)' },\r\n            { id: '--dark-text-very-muted', value: 'rgba(248, 248, 248, 0.1)' },\r\n            { id: '--dark-text-hidden', value: 'rgba(248, 248, 248, 0)' },\r\n            { id: '--light-text', value: '#444444' },\r\n            { id: '--light-text-muted', value: 'rgba(68, 68, 68, 0.6)' },\r\n            { id: '--light-text-very-muted', value: 'rgba(68, 68, 68, 0.1)' },\r\n            { id: '--light-text-hidden', value: 'rgba(68, 68, 68, 0)' },\r\n            { id: '--dark-background', value: '#f8f8f8' },\r\n            { id: '--dark-background-alt', value: 'rgba(248, 248, 248, 0.95)' },\r\n            { id: '--light-background', value: '#444444' },\r\n            { id: '--light-background-alt', value: 'rgba(68, 68, 68, 0.95)' }\r\n        ];\r\n        var root = document.querySelector(':root');\r\n        mode.forEach((m) => {\r\n            root.style.setProperty(m.id, m.value);\r\n        });\r\n    }\r\n    static applyLightMode() {\r\n        const mode = [\r\n            { id: '--dark-text', value: '#444444' },\r\n            { id: '--dark-text-muted', value: 'rgba(68, 68, 68, 0.6)' },\r\n            { id: '--dark-text-very-muted', value: 'rgba(68, 68, 68, 0.1)' },\r\n            { id: '--dark-text-hidden', value: 'rgba(68, 68, 68, 0)' },\r\n            { id: '--light-text', value: '#f8f8f8' },\r\n            { id: '--light-text-muted', value: 'rgba(248, 248, 248, 0.6)' },\r\n            { id: '--light-text-very-muted', value: 'rgba(248, 248, 248, 0.1)' },\r\n            { id: '--light-text-hidden', value: 'rgba(248, 248, 248, 0)' },\r\n            { id: '--dark-background', value: '#444444' },\r\n            { id: '--dark-background-alt', value: 'rgba(68, 68, 68, 0.95)' },\r\n            { id: '--light-background', value: '#f8f8f8' },\r\n            { id: '--light-background-alt', value: 'rgba(248, 248, 248, 0.95)' }\r\n        ];\r\n        var root = document.querySelector(':root');\r\n        mode.forEach((m) => {\r\n            root.style.setProperty(m.id, m.value);\r\n        });\r\n    }\r\n    static arrayRemove(arr, elementToRemove) {\r\n        return arr.filter(function (element) {\r\n            return element != elementToRemove;\r\n        });\r\n    }\r\n    // Returns 'a' or 'an' if str's first char is a consonant or a vowel\r\n    static aOrAn(str) {\r\n        return Util.startsWithVowel(str) ? 'an' : 'a';\r\n    }\r\n    // Returns true if the string ends with a given str\r\n    static endsWith(str, endingStr) {\r\n        const regex = new RegExp('.*' + endingStr + '$');\r\n        return regex.test(str);\r\n    }\r\n    // Returns true if the string starts with a vowel\r\n    static startsWithVowel(str) {\r\n        const regex = new RegExp('^[aeiou].*', 'i');\r\n        return regex.test(str);\r\n    }\r\n    // Returns true if the string starts with a vowel\r\n    static endsWithVowel(str) {\r\n        const regex = new RegExp('.*[aeiou]$', 'i');\r\n        return regex.test(str);\r\n    }\r\n    // Returns a string joining an array of at least two entries\r\n    // with commas and the word 'and' between the last two entries\r\n    static joinArrayWithAnd(arr) {\r\n        const last = arr.pop();\r\n        if (arr.length == 1) {\r\n            return arr[0] + ' and ' + last;\r\n        }\r\n        let str = arr.join(', ');\r\n        str += ', and ' + last;\r\n        return str;\r\n    }\r\n    // Tweet a realm\r\n    static shareByTweet(realm) {\r\n        let tweet = `Explore ${Util.capitalize(Lang.readWord(realm.realmName.name))}, a ${realm.size} ${realm.parentEntity.adjective} ${realm.government.rank}.`;\r\n        window.open('https://twitter.com/intent/tweet?url=' +\r\n            window.location.href +\r\n            '&text=' +\r\n            tweet, '_blank');\r\n    }\r\n    // Capitalize first letter\r\n    static capitalize(str) {\r\n        return str.charAt(0).toUpperCase() + str.substring(1);\r\n    }\r\n    // Returns any number lower than 20 as a word ('one', 'two', ... 'nineteen')\r\n    static wordFromNumber(n) {\r\n        const words = [\r\n            'zero',\r\n            'one',\r\n            'two',\r\n            'three',\r\n            'four',\r\n            'five',\r\n            'six',\r\n            'seven',\r\n            'eight',\r\n            'nine',\r\n            'ten',\r\n            'eleven',\r\n            'twelve',\r\n            'thirteen',\r\n            'fourteen',\r\n            'fifteen',\r\n            'sixteen',\r\n            'seventeen',\r\n            'eighteen',\r\n            'nineteen'\r\n        ];\r\n        return n < words.length ? words[n] : n.toString();\r\n    }\r\n}\r\nUtil.isDarkMode = false;\r\n","import Rand from '../Rand';\r\nimport Language from '../toponymy/Language';\r\nimport PageController from './PageController';\r\nexport default class HomePageController extends PageController {\r\n    constructor() {\r\n        super();\r\n        this.handleControls();\r\n        this.handleFavorites();\r\n    }\r\n    handleControls() { }\r\n    handleFavorites() {\r\n        // Get favorites from local storage\r\n        if (!localStorage.getItem('favorites'))\r\n            localStorage.setItem('favorites', JSON.stringify([]));\r\n        let favorites = JSON.parse(localStorage.getItem('favorites'));\r\n        // Handle the favorites badges\r\n        const favoritesEl = document.getElementById('favorites');\r\n        favoritesEl.addEventListener('click', (event) => {\r\n            const removeId = event.target.getAttribute('removeId');\r\n            if (removeId) {\r\n                favorites = favorites.filter((f) => f.id != removeId);\r\n                event.preventDefault();\r\n                localStorage.setItem('favorites', JSON.stringify(favorites));\r\n                refreshFavorites();\r\n            }\r\n        });\r\n        const btnFavorite = document.getElementById('btnFavorite');\r\n        btnFavorite.addEventListener('click', () => {\r\n            const f = {\r\n                id: Rand.seed,\r\n                name: Language.readWord(this.realm.realmName.name)\r\n            };\r\n            if (!favorites.some((v) => f.id == v.id)) {\r\n                favorites.push(f);\r\n            }\r\n            else {\r\n                favorites = favorites.filter((v) => v.id != f.id);\r\n            }\r\n            localStorage.setItem('favorites', JSON.stringify(favorites));\r\n            refreshFavorites();\r\n        });\r\n        const btnFavoriteIcon = document.querySelector('#btnFavorite i');\r\n        const btnFavoriteText = document.querySelector('#btnFavorite span');\r\n        function refreshFavorites() {\r\n            btnFavoriteIcon.classList.remove('fa-solid', 'fa-regular', 'selected');\r\n            // Is the current realm already favorited?\r\n            const isFavorite = favorites.some((f) => f.id == Rand.seed);\r\n            btnFavoriteIcon.classList.add(isFavorite ? 'fa-solid' : 'fa-regular');\r\n            btnFavoriteText.innerHTML = isFavorite\r\n                ? 'This is one of your favorites'\r\n                : 'Add this Realm to your favorites';\r\n            // Create favorite badges\r\n            favoritesEl.innerHTML = '';\r\n            favorites.forEach((f) => {\r\n                let url = window.location.href;\r\n                url = url.substring(0, url.indexOf('?')) + '?' + f.id;\r\n                favoritesEl.innerHTML += `\r\n  <li class=\"favorite-badge\">\r\n    <a href=\"${url}\" target=\"_self\" class=\"btn btn--icon capitalized\">${f.name}</a>\r\n    <a class=\"btn btn--icon delete-favorite\">\r\n      <i class=\"fa-solid fa-xmark\" removeId=\"${f.id}\"></i>\r\n    </a>\r\n  </li>`;\r\n            });\r\n        }\r\n    }\r\n}\r\n","import PageController from \"./PageController\";\r\nexport default class JSONPageController extends PageController {\r\n    constructor() {\r\n        super();\r\n    }\r\n}\r\n// const jsonContainer: HTMLElement =\r\n// document.querySelector('.container--json')!;\r\n// if (arr && arr.length > 1) {\r\n// // Show JSON\r\n// jsonContainer.classList.remove('hidden');\r\n// const jsonContent: HTMLElement = document.querySelector('.json-content')!;\r\n// jsonContent.innerHTML =\r\n//   '<pre class=\"json-format\">' +\r\n//   JSON.stringify(realm, null, '  ') +\r\n//   '</pre>';\r\n// handleJsonButtons();\r\n// // Hide content\r\n// const content: HTMLElement = document.querySelector('div.content')!;\r\n// content.classList.add('hidden');\r\n// applyText('name', Util.readWord(realm.realmName));\r\n// } else {\r\n// // Don't show JSON\r\n// jsonContainer.innerHTML = '';\r\n// updateView();\r\n// }\r\n","import Rand from '../Rand';\r\nimport Realm from '../realm/Realm';\r\nimport Util from '../Util';\r\nexport default class PageController {\r\n    constructor(realm) {\r\n        this.realm = realm;\r\n        this.handleSeed();\r\n        this.handleDarkMode();\r\n        this.realm = new Realm();\r\n        // Fade in sections once the realm has been initialized\r\n        this.fadeInSections();\r\n    }\r\n    handleSeed() {\r\n        // Does the url contain a seed (query)?\r\n        // www.google.com?foo\r\n        //    -> foo\r\n        // www.google.com?bar#\r\n        //    -> bar\r\n        const url = window.location.href;\r\n        const arr = url.match(/\\?([a-z0-9,-]+)/);\r\n        if (arr && arr.length > 1) {\r\n            Rand.seed = arr[1];\r\n        }\r\n        else {\r\n            Rand.generateSeed();\r\n            let url = window.location.href;\r\n            url = url.substring(0, url.indexOf('?'));\r\n            if (window.location.href)\r\n                window.location.replace(url + '?' + Rand.seed);\r\n            // Page refreshes here, forcing the first condition\r\n        }\r\n    }\r\n    fadeInSections() {\r\n        // Delay intro animations\r\n        const sectionEls = document.querySelectorAll('.container');\r\n        sectionEls.forEach((node, index) => {\r\n            const el = node;\r\n            setTimeout(() => {\r\n                el.classList.add('fade-in');\r\n            }, 100 * index);\r\n        });\r\n    }\r\n    handleDarkMode() {\r\n        // Initial local preferences\r\n        const darkModeAtStart = localStorage.getItem('darkMode');\r\n        const isDarkModeAtStart = darkModeAtStart != null && darkModeAtStart == 'true';\r\n        isDarkModeAtStart ? Util.toggleDarkMode() : null;\r\n        // Handle dark mode button\r\n        const btnToggleDarkMode = document.getElementById('btnToggleDarkMode');\r\n        btnToggleDarkMode.addEventListener('click', () => {\r\n            Util.toggleDarkMode();\r\n            // Add the background-transition class to the body if it's not already there\r\n            const body = document.querySelector('body');\r\n            if (!body.classList.contains('background-transition')) {\r\n                body.classList.add('background-transition');\r\n            }\r\n        });\r\n    }\r\n}\r\n","export default class Module {\r\n    constructor(realm) {\r\n        this._realm = realm;\r\n        this.run();\r\n    }\r\n    run() { }\r\n}\r\n// Module child class template\r\n// import Module from '../Module';\r\n// import Realm from '../../realm/Realm';\r\n// export default class xModule extends Module {\r\n//   constructor(realm: Realm) {\r\n//     super(realm);\r\n//   }\r\n//   protected run() {\r\n//   }\r\n// }\r\n","import Module from '../Module';\r\nimport { governments } from './governments.json';\r\nimport Rand from '../../Rand';\r\nexport default class GovernmentModule extends Module {\r\n    constructor(realm) {\r\n        super(realm);\r\n    }\r\n    run() {\r\n        // Government\r\n        let government;\r\n        do {\r\n            government = Rand.pick(governments);\r\n        } while (!government.size.includes(this._realm.size.sizeIndex));\r\n        this.rank = government.rank;\r\n        this.ruler = government.ruler;\r\n        this._realm.tags.push(this.rank);\r\n    }\r\n}\r\n","import Module from '../Module';\r\nimport { sigils } from './sigils.json';\r\nimport { ordinaries, layouts, charges, metalTinctures, colorTinctures } from './heraldry.json';\r\nimport Rand from '../../Rand';\r\nexport default class HeraldryModule extends Module {\r\n    constructor(realm) {\r\n        super(realm);\r\n    }\r\n    run() {\r\n        // Sigil\r\n        let sigil = Rand.pick(sigils);\r\n        sigil.meaning = Rand.pick(sigil.meaning);\r\n        // Ordinary\r\n        this.ordinary = Rand.weightedPick(ordinaries, (item) => item.points);\r\n        // Choose exactly one metal tincture and one color tincture\r\n        let metal = Rand.weightedPick(metalTinctures, (item) => item.points);\r\n        let color = Rand.weightedPick(colorTinctures, (item) => item.points);\r\n        this.tinctures = [metal, color].sort((t) => (Rand.next() > 0.5 ? 1 : -1));\r\n        // Charge Layout\r\n        const availableLayouts = layouts.filter((l) => this.ordinary.layouts.some((m) => m.name == l.name));\r\n        this.chargeLayout =\r\n            this.ordinary.layouts.length > 0\r\n                ? Rand.weightedPick(availableLayouts, (l) => l.points)\r\n                : null;\r\n        if (!this.chargeLayout)\r\n            return;\r\n        // Charge tincture\r\n        // Heraldic rule: Never put a color on another color\r\n        // and never put a metal on top of another metal\r\n        const tinctureOverlapIndexes = this.ordinary.layouts.find((l) => l.name == this.chargeLayout.name).overlap;\r\n        let availableTinctures = metalTinctures;\r\n        if (tinctureOverlapIndexes.length > 0) {\r\n            const overlapTincture = this.tinctures[tinctureOverlapIndexes[0]];\r\n            if (overlapTincture.type == 'color') {\r\n                availableTinctures = colorTinctures;\r\n            }\r\n        }\r\n        this.chargeTincture = Rand.pick(availableTinctures);\r\n        // Pick a charge\r\n        this.charge = Rand.weightedPick(charges, (item) => item.points);\r\n        if (this.chargeLayout.count < 3) {\r\n            this.charge = { name: sigil.name, points: 0, url: sigil.icon };\r\n        }\r\n        // Is it the sigil used on the heraldry? Add a tag if it is\r\n        if (this.charge.name == sigil.name)\r\n            this._realm.addTag('sigilAsCharge');\r\n    }\r\n}\r\n","import Rand from '../../Rand';\r\nimport { BiomeType } from '../geography/BiomesModule';\r\nimport Module from '../Module';\r\nexport var Direction;\r\n(function (Direction) {\r\n    Direction[\"NORTH\"] = \"north\";\r\n    Direction[\"NORTH_EAST\"] = \"north-east\";\r\n    Direction[\"EAST\"] = \"east\";\r\n    Direction[\"SOUTH_EAST\"] = \"south-east\";\r\n    Direction[\"SOUTH\"] = \"south\";\r\n    Direction[\"SOUTH_WEST\"] = \"south-west\";\r\n    Direction[\"WEST\"] = \"west\";\r\n    Direction[\"NORTH_WEST\"] = \"north-west\";\r\n})(Direction || (Direction = {}));\r\nexport default class LocationModule extends Module {\r\n    constructor(realm) {\r\n        super(realm);\r\n        this.locationWithinParentEntity = Direction.NORTH;\r\n        this.directionToCoast = null;\r\n    }\r\n    run() {\r\n        this.locationWithinParentEntity = Rand.pick(Object.values(Direction));\r\n        // Add direction tags south-west => south, west\r\n        this.locationWithinParentEntity\r\n            .split('-')\r\n            .forEach((l) => this._realm.addTag(l));\r\n        // 40% chance to be coastal\r\n        if (Rand.next() < 0.4) {\r\n            this.directionToCoast = this.locationWithinParentEntity;\r\n            this._realm.addTag(BiomeType.COAST);\r\n        }\r\n    }\r\n    static isCardinalDirection(direction) {\r\n        return !direction.includes('-');\r\n    }\r\n}\r\n","import Rand from '../../Rand';\r\nimport Module from '../Module';\r\nimport { placeRoots, placeSuffixes } from './place-names.json';\r\nexport default class RealmNameModule extends Module {\r\n    constructor(realm) {\r\n        super(realm);\r\n    }\r\n    run() {\r\n        // Roots cannot be used by an existing river\r\n        const roots = [...placeRoots];\r\n        let validRoots = roots.filter((p) => this._realm.evaluateCondition(p.condition));\r\n        const root = Object.assign({}, Rand.weightedPick(validRoots, (item) => item.points));\r\n        const suffixes = [...placeSuffixes];\r\n        let validSuffixes = suffixes.filter((p) => this._realm.evaluateCondition(p.condition));\r\n        let suffix;\r\n        do {\r\n            suffix = Rand.weightedPick(validSuffixes, (item) => item.points);\r\n            this.name = { root: root, suffix: suffix };\r\n        } while (!this.isValidRealmName(this.name));\r\n    }\r\n    isValidRealmName(word) {\r\n        let valid = true;\r\n        // Root and suffix can't be the same\r\n        if (word.root == word.suffix)\r\n            return false;\r\n        return valid;\r\n    }\r\n}\r\n","import Module from '../Module';\r\nimport Rand from '../../Rand';\r\nimport Util from '../../Util';\r\nimport { Direction } from '../general/LocationModule';\r\nimport { Humidity, Temperature } from './ClimateModule';\r\nexport var BiomeType;\r\n(function (BiomeType) {\r\n    BiomeType[\"GRASSLAND\"] = \"grassland\";\r\n    BiomeType[\"TUNDRA\"] = \"tundra\";\r\n    BiomeType[\"BOREAL_FOREST\"] = \"borealForest\";\r\n    BiomeType[\"TEMPERATE_FOREST\"] = \"temperateForest\";\r\n    BiomeType[\"MOUNTAINS\"] = \"mountains\";\r\n    BiomeType[\"COAST\"] = \"coast\";\r\n})(BiomeType || (BiomeType = {}));\r\nexport default class BiomesModule extends Module {\r\n    constructor(realm) {\r\n        super(realm);\r\n    }\r\n    run() {\r\n        this.biomes = [];\r\n        // Add a coast biome\r\n        let remainingSize = this._realm.size.sizeIndex + 1;\r\n        if (this._realm.tags.includes(BiomeType.COAST)) {\r\n            const coastBiome = {\r\n                type: BiomeType.COAST,\r\n                size: Rand.between(1, remainingSize, true),\r\n                direction: this._realm.location.directionToCoast\r\n            };\r\n        }\r\n        // Limit available biome types\r\n        let availableBiomeTypes = Object.values(BiomeType).filter((biomeType) => {\r\n            if (biomeType == BiomeType.COAST)\r\n                return false;\r\n            switch (this._realm.climate.humidity) {\r\n                case Humidity.DRY:\r\n                    // Dry? Remove boreal-forest and temperate-forest\r\n                    return ![\r\n                        BiomeType.BOREAL_FOREST,\r\n                        BiomeType.TEMPERATE_FOREST\r\n                    ].includes(biomeType);\r\n                    break;\r\n                case Humidity.WET:\r\n                    // Wet? Remove grassland and tundra\r\n                    return ![BiomeType.GRASSLAND, BiomeType.TUNDRA].includes(biomeType);\r\n                    break;\r\n            }\r\n            if (this._realm.climate.temperature == Temperature.WARM) {\r\n                // Warm? Remove boreal-forest and tundra\r\n                return ![BiomeType.BOREAL_FOREST, BiomeType.TUNDRA].includes(biomeType);\r\n            }\r\n            return true;\r\n        });\r\n        // Cannot be a combined direction like north-east or south-west, must be one of the four cardinal directions or 'middle'\r\n        let availableDirections = Object.values(Direction).filter((d) => d.split('-').length == 1);\r\n        // Create some number of biomes\r\n        while (remainingSize > 0 && availableBiomeTypes.length > 0) {\r\n            let biomeSize = Rand.between(1, remainingSize, true);\r\n            remainingSize -= biomeSize;\r\n            let biomeType = Rand.pick(availableBiomeTypes);\r\n            availableBiomeTypes = Util.arrayRemove(availableBiomeTypes, biomeType);\r\n            let biomeDirection = Rand.pick(availableDirections);\r\n            availableDirections = Util.arrayRemove(availableDirections, biomeDirection);\r\n            const biome = {\r\n                type: biomeType,\r\n                size: biomeSize,\r\n                direction: biomeDirection\r\n            };\r\n            this.biomes.push(biome);\r\n            this._realm.addTag(biomeType);\r\n        }\r\n    }\r\n}\r\n","import Module from '../Module';\r\nimport Rand from '../../Rand';\r\nimport Util from '../../Util';\r\nimport { Direction } from '../general/LocationModule';\r\nimport { summer, winter } from './season-descriptions.json';\r\nexport var Temperature;\r\n(function (Temperature) {\r\n    Temperature[\"COLD\"] = \"cold\";\r\n    Temperature[\"TEMPERATE\"] = \"temperate\";\r\n    Temperature[\"WARM\"] = \"warm\";\r\n})(Temperature || (Temperature = {}));\r\nexport var Humidity;\r\n(function (Humidity) {\r\n    Humidity[\"WET\"] = \"wet\";\r\n    Humidity[\"DRY\"] = \"dry\";\r\n})(Humidity || (Humidity = {}));\r\nexport default class ClimateModule extends Module {\r\n    constructor(realm) {\r\n        super(realm);\r\n        this.summerAdjectives = [];\r\n        this.winterAdjectives = [];\r\n    }\r\n    run() {\r\n        // Temperature: Default is TEMPERATE\r\n        // If location is in the north, 60% chance COLD\r\n        // If location is in the south, 60% chance WARM\r\n        if (this._realm.location.locationWithinParentEntity.includes(Direction.NORTH)) {\r\n            this.temperature =\r\n                Rand.next() < 0.6 ? Temperature.COLD : Temperature.TEMPERATE;\r\n        }\r\n        else if (this._realm.location.locationWithinParentEntity.includes(Direction.SOUTH)) {\r\n            this.temperature =\r\n                Rand.next() < 0.6 ? Temperature.WARM : Temperature.TEMPERATE;\r\n        }\r\n        else {\r\n            this.temperature = Temperature.TEMPERATE;\r\n        }\r\n        this._realm.addTag(this.temperature);\r\n        // Humidity\r\n        if (this._realm.tags.includes('coast')) {\r\n            this.humidity = Humidity.WET;\r\n        }\r\n        else {\r\n            this.humidity = Rand.pick(Object.values(Humidity));\r\n        }\r\n        this._realm.addTag(this.humidity);\r\n        // Choose words to describe summer and winter\r\n        this.summerAdjectives = this.chooseSeasonAdjectives(summer[this.temperature].concat(summer[this.humidity]));\r\n        this.winterAdjectives = this.chooseSeasonAdjectives(winter[this.temperature].concat(winter[this.humidity]));\r\n    }\r\n    chooseSeasonAdjectives(adjectives) {\r\n        let arr = [];\r\n        for (let i = 0; i < 2; i++) {\r\n            const adjective = Rand.pick(adjectives);\r\n            arr.push(adjective);\r\n            adjectives = Util.arrayRemove(adjectives, adjective);\r\n            //  If the word is longer than 6 letters, step out of the loop\r\n            //  Otherwise, 50% chance to step out of the loop\r\n            if (Rand.next() < 0.5 || adjective.length > 6)\r\n                break;\r\n        }\r\n        return arr;\r\n    }\r\n}\r\n","import Rand from '../../Rand';\r\nimport Module from '../Module';\r\nimport { adjectives, governments, templates } from './parent-entity.json';\r\nexport default class ParentEntityModule extends Module {\r\n    constructor(realm) {\r\n        super(realm);\r\n    }\r\n    run() {\r\n        const template = Rand.pick(templates);\r\n        this.adjective = Rand.pick(adjectives);\r\n        this.government = Rand.pick(governments);\r\n        const adjective = this.adjective;\r\n        const government = this.government.noun;\r\n        this.name = eval(template);\r\n    }\r\n}\r\n","import Rand from '../../Rand';\r\nimport Util from '../../Util';\r\nimport LocationModule, { Direction } from '../general/LocationModule';\r\nimport Module from '../Module';\r\nimport { BiomeType } from './BiomesModule';\r\nimport { Humidity } from './ClimateModule';\r\nimport { riverSuffixes, roots, tributaryPrefixes, tributarySuffixes } from './river-names.json';\r\nexport default class RiversModule extends Module {\r\n    constructor(realm) {\r\n        super(realm);\r\n    }\r\n    run() {\r\n        this.rivers = [];\r\n        this.tributaries = [];\r\n        // Pick a number of rivers\r\n        let riverCount = 0;\r\n        switch (this._realm.climate.humidity) {\r\n            case Humidity.DRY:\r\n                riverCount = Rand.between(0, 2, true);\r\n                break;\r\n            case Humidity.WET:\r\n                riverCount = Rand.between(2, 4, true);\r\n        }\r\n        // For small realms, there should only be one river\r\n        if (this._realm.size.sizeIndex < 2) {\r\n            riverCount = 1;\r\n        }\r\n        // Add rivers\r\n        for (let i = 0; i < riverCount; i++)\r\n            this.addNewRiver();\r\n    }\r\n    addNewRiver() {\r\n        // Determine the directions (to and from) the river will flow\r\n        // Rivers tend to flow from mountains towards coasts, so factor this in if those biomes are present\r\n        const mountains = this._realm.biomes.biomes.find((b) => b.type == BiomeType.MOUNTAINS) ||\r\n            null;\r\n        const coast = this._realm.biomes.biomes.find((b) => b.type == BiomeType.COAST) || null;\r\n        // Only use cardinal directions\r\n        let availableDirections = Object.values(Direction).filter((d) => LocationModule.isCardinalDirection(d) &&\r\n            (!coast || d != coast.direction) &&\r\n            (!mountains || d != mountains.direction));\r\n        let flowsFrom = mountains && Rand.next() < 0.8\r\n            ? mountains.direction\r\n            : Rand.pick(availableDirections);\r\n        // Rivers can't flow to the same place they're flowing from\r\n        Util.arrayRemove(availableDirections, flowsFrom);\r\n        let flowsTo = coast\r\n            ? coast.direction\r\n            : Rand.pick(availableDirections);\r\n        const riverName = this.getRiverName();\r\n        const tributaries = this.getTributaries(riverName);\r\n        let river = {\r\n            name: riverName,\r\n            flowsTo: flowsTo,\r\n            flowsFrom: flowsFrom,\r\n            flowsToCoast: coast,\r\n            flowsFromMountains: mountains,\r\n            tributaries: tributaries\r\n        };\r\n        this.rivers.push(river);\r\n    }\r\n    getRiverName() {\r\n        // Roots cannot be used by an existing river\r\n        let validRoots = roots.filter((p) => this.rivers.every((r) => r.name.root.text != p.text) &&\r\n            this._realm.evaluateCondition(p.condition));\r\n        let validSuffixes = riverSuffixes.filter((p) => this._realm.evaluateCondition(p.condition));\r\n        let riverName;\r\n        do {\r\n            let root = Rand.weightedPick(validRoots, (item) => item.points);\r\n            let suffix = Rand.weightedPick(validSuffixes, (item) => item.points);\r\n            riverName = { root: root, suffix: suffix };\r\n        } while (!this.isValidRiverName(riverName));\r\n        return riverName;\r\n    }\r\n    getTributaries(riverName) {\r\n        let tributaries = [];\r\n        const tributaryCount = Rand.between(0, 3);\r\n        for (let i = 0; i < tributaryCount; i++) {\r\n            const tributaryName = i == 0 && Rand.next() < 0.6 ? riverName : this.getRiverName();\r\n            // If the tributary name is the same as the stem, choose a tributary prefix and/or suffix\r\n            let prefix = null;\r\n            let suffix = null;\r\n            do {\r\n                if (riverName == tributaryName) {\r\n                    do {\r\n                        if (Rand.next() < 0.3)\r\n                            prefix = Rand.weightedPick(tributaryPrefixes, (item) => item.points);\r\n                        if (Rand.next() < 0.3)\r\n                            suffix = Rand.weightedPick(tributarySuffixes, (item) => item.points);\r\n                    } while (!prefix && !suffix);\r\n                }\r\n            } while (!this.isValidRiverName(tributaryName));\r\n            let tributary = {\r\n                name: tributaryName,\r\n                prefix: prefix,\r\n                suffix: suffix,\r\n                stem: null\r\n            };\r\n            // The more tributaries there are the lower the chance is to add a new one\r\n            const max = 5;\r\n            const remaining = max - this.tributaries.length;\r\n            const chance = remaining * (1 / max) + 0.1; // Always give it +10% chance\r\n            if (Rand.next() >= chance)\r\n                continue;\r\n            // Push to river tributary array (gets returned)\r\n            tributaries.push(tributary);\r\n            // Push to top level tributary array (of all tributaries)\r\n            this.tributaries.push(tributary);\r\n        }\r\n        return tributaries;\r\n    }\r\n    isValidRiverName(riverName) {\r\n        // Can't have two vowels next to each other\r\n        if (Util.endsWithVowel(riverName.root.text) &&\r\n            Util.startsWithVowel(riverName.suffix.text)) {\r\n            return false;\r\n        }\r\n        // No two rivers or tributaries can have the same name\r\n        const riverAndTributaryNames = this.tributaries\r\n            .map((t) => t.name)\r\n            .concat(this.rivers.map((r) => r.name));\r\n        if (riverAndTributaryNames.includes(riverName)) {\r\n            return false;\r\n        }\r\n        // Rivers' roots cannot end in their suffix (Hennen-en, Frau-au, etc.)\r\n        if (riverName.root.text.indexOf(riverName.suffix.text) ==\r\n            riverName.root.text.length - riverName.suffix.text.length) {\r\n            return false;\r\n        }\r\n        return true;\r\n    }\r\n}\r\n","import Module from '../Module';\r\nimport Rand from '../../Rand';\r\nexport var Size;\r\n(function (Size) {\r\n    Size[\"VERY_SMALL\"] = \"very small\";\r\n    Size[\"SMALL\"] = \"small\";\r\n    Size[\"MEDIUM\"] = \"medium\";\r\n    Size[\"LARGE\"] = \"large\";\r\n    Size[\"VERY_LARGE\"] = \"very large\";\r\n})(Size || (Size = {}));\r\nexport default class SizeModule extends Module {\r\n    constructor(realm) {\r\n        super(realm);\r\n    }\r\n    run() {\r\n        this.size = Rand.pick(Object.values(Size));\r\n        this._realm.addTag(this.size == Size.VERY_SMALL ? 'city' : 'region');\r\n    }\r\n    get sizeIndex() {\r\n        return Object.values(Size).indexOf(this.size);\r\n    }\r\n}\r\n","import SizeModule from '../modules/geography/SizeModule';\r\nimport LocationModule from '../modules/general/LocationModule';\r\nimport ParentEntityModule from '../modules/geography/ParentEntityModule';\r\nimport ClimateModule from '../modules/geography/ClimateModule';\r\nimport BiomesModule from '../modules/geography/BiomesModule';\r\nimport RiversModule from '../modules/geography/RiversModule';\r\nimport HeraldryModule from '../modules/general/HeraldryModule';\r\nimport GovernmentModule from '../modules/general/GovernmentModule';\r\nimport RealmNameModule from '../modules/general/RealmNameModule';\r\nexport default class Realm {\r\n    constructor() {\r\n        // Tags\r\n        this._tags = [];\r\n        this.runModules();\r\n    }\r\n    runModules() {\r\n        this.size = new SizeModule(this);\r\n        this.location = new LocationModule(this);\r\n        this.parentEntity = new ParentEntityModule(this);\r\n        this.climate = new ClimateModule(this);\r\n        this.biomes = new BiomesModule(this);\r\n        this.rivers = new RiversModule(this);\r\n        this.heraldry = new HeraldryModule(this);\r\n        this.government = new GovernmentModule(this);\r\n        this.realmName = new RealmNameModule(this);\r\n    }\r\n    addTag(tag) {\r\n        this._tags.push(tag);\r\n    }\r\n    get tags() {\r\n        return this._tags;\r\n    }\r\n    evaluateCondition(condition) {\r\n        if (condition == '')\r\n            return true;\r\n        let u = {};\r\n        this.tags.forEach((t) => (u[t] = true));\r\n        return new ConditionEvaluator().run(condition, u);\r\n    }\r\n}\r\nclass ConditionEvaluator {\r\n    constructor() { }\r\n    run(condition, t) {\r\n        // Regex instead?\r\n        const result = eval(`(${condition})`) ? true : false;\r\n        return result;\r\n    }\r\n}\r\n","export default class Language {\r\n    static readWord(word) {\r\n        return word.root.text + word.suffix.text;\r\n    }\r\n}\r\n","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","/**\r\n * Hint: Use 'npm run build' from console to compile + watch the TS code on save\r\n */\r\nimport HomePageController from './controllers/HomePageController';\r\nimport JSONPageController from './controllers/JSONPageController';\r\n// Is it json?\r\nconst arr = window.location.href.match(/\\?[a-z0-9,-]+.*\\&(json)/);\r\nlet controller;\r\nif (arr && arr.length > 1) {\r\n    // Show JSON\r\n    controller = new JSONPageController();\r\n}\r\nelse {\r\n    // Show Home\r\n    controller = new HomePageController();\r\n}\r\n"],"names":[],"sourceRoot":""}