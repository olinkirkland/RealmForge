{"version":3,"file":"bundle.js","mappings":";;;;;;;;;;;;;;AAAO;AACP;AACA;AACA,cAAc,6DAA6D;AAC3E,cAAc,yDAAyD;AACvE;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC,SAAS;AAClD;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,sCAAsC,SAAS;AAC/C;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;AC1E8B;AACA;AACvB;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,4CAAS;AACrB,kCAAkC,mDAAgB,CAAC,qEAAkC;AACrF;AACA,gBAAgB,4CAAS;AACzB,uCAAuC,mDAAgB,CAAC,qEAAkC;AAC1F;AACA;AACA;AACA;AACA,yBAAyB,mDAAgB,CAAC,+DAA4B;AACtE;AACA;AACA;AACA,YAAY,4CAAS;AACrB,qBAAqB,mDAAgB,CAAC,oEAAiC;AACvE;AACA;AACA;AACA;AACA,oBAAoB,mDAAgB,CAAC,kDAAe;AACpD;AACA;AACA;AACA;AACA,YAAY,4CAAS;AACrB;AACA;AACA,oCAAoC,4CAAS,KAAK,oDAAiB;AACnE,oBAAoB,6CAAU;AAC9B;AACA;AACA;AACA;AACA,mBAAmB,mDAAgB,CAAC,uDAAoB;AACxD,UAAU;AACV;AACA;AACA;AACA;AACA,oBAAoB,mDAAgB,CAAC,8CAAW;AAChD;AACA;AACA,4BAA4B,mDAAgB;AAC5C,sCAAsC,4CAAS;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,mDAAgB;AACxC;AACA;AACA;AACA;AACA;AACA,uBAAuB,gEAA6B;AACpD;AACA,wBAAwB,OAAO;AAC/B,sBAAsB,mDAAgB;AACtC;AACA,yCAAyC,mDAAgB;AACzD,gBAAgB,4CAAS;AACzB;AACA;AACA;AACA;AACA,uBAAuB,gEAA6B;AACpD;AACA,wBAAwB,OAAO;AAC/B,sBAAsB,mDAAgB;AACtC;AACA;AACA;AACA;AACA,yCAAyC,mDAAgB;AACzD,gBAAgB,4CAAS;AACzB;AACA;AACA;AACA;AACA;AACA,8BAA8B,qDAAkB;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,gBAAgB,mDAAgB;AAChC;AACA,gBAAgB,mDAAgB;AAChC,0BAA0B,mDAAgB;AAC1C,iCAAiC,qDAAkB;AACnD,mCAAmC,4CAAS;AAC5C;AACA;AACA;AACA,kBAAkB,6CAAU;AAC5B,uBAAuB,mDAAgB,CAAC,kDAAe;AACvD;AACA;AACA,YAAY,4CAAS;AACrB;AACA;AACA;AACA;AACA,qCAAqC,mDAAgB,CAAC,kDAAe;AACrE,cAAc;AACd;AACA;AACA,sBAAsB,mDAAgB;AACtC,sBAAsB,6CAAU,YAAY,4CAAS;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,4CAAS;AAC7C;AACA;AACA;AACA;AACA,mCAAmC,eAAe;AAClD;AACA,wBAAwB,gBAAgB;AACxC;AACA,4BAA4B,mDAAgB,CAAC,kDAAe;AAC5D;AACA,0BAA0B,mDAAgB,CAAC,kDAAe;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,QAAQ;AAChC,qBAAqB,gDAAa;AAClC;AACA;AACA;AACA;AACA,+BAA+B,mDAAgB;AAC/C,wBAAwB,oBAAoB;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,6DACN,CAAC,sDAAmB;AACvC,oBAAoB,sDAAmB;AACvC,oBAAoB,uDAAoB;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,mBAAmB,mDAAgB;AACnC;AACA;AACA,wBAAwB,mDAAgB;AACxC;AACA;AACA,4BAA4B,6DAA0B;AACtD;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,yBAAyB,mDAAgB;AACzC;AACA;AACA,8BAA8B,mDAAgB;AAC9C;AACA,0BAA0B;AAC1B,UAAU;AACV;AACA;AACA,gBAAgB,qDAAkB;AAClC,gBAAgB,uDAAoB;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;AC7Q8B;AACvB;AACP;AACA;AACA,wBAAwB,OAAO;AAC/B,sCAAsC,6CAAU;AAChD;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,sBAAsB;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,4BAA4B,MAAM,YAAY,EAAE,uBAAuB,EAAE,qBAAqB;AAC7H;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;UC1GA;UACA;;UAEA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;;UAEA;UACA;;UAEA;UACA;UACA;;;;;WCtBA;WACA;WACA;WACA;WACA,yCAAyC,wCAAwC;WACjF;WACA;WACA;;;;;WCPA;;;;;WCAA;WACA;WACA;WACA,uDAAuD,iBAAiB;WACxE;WACA,gDAAgD,aAAa;WAC7D;;;;;;;;;;;;;;ACN8B;AACA;AACE;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI,oDAAiB;AACrB,CAAC;AACD;AACA,6CAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,4CAAS;AACjB;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA,IAAI,oDAAiB;AACrB;AACA;AACA;AACA,4CAA4C,4CAAS;AACrD;AACA;AACA;AACA,IAAI,iEAA8B;AAClC,gBAAgB,yCAAK;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,KAAK;AACL;AACA;AACA;AACA;AACA,mHAAmH,wBAAwB;AAC3I;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,mDAAgB,CAAC,8CAAW;AACvC;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,6CAAU;AACvC;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,2DAA2D,OAAO;AAClE;AACA;AACA;AACA;AACA,iFAAiF,SAAS,SAAS,SAAS,EAAE,SAAS,gBAAgB,kBAAkB;AACzJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gHAAgH,gDAAa,SAAS,yCAAyC,gDAAa,SAAS,wBAAwB,kBAAkB,uBAAuB,eAAe;AACrR;AACA;AACA,wDAAwD,oBAAoB,0DAA0D,wDAAqB;AAC3J,oDAAoD,gDAAa,aAAa;AAC9E,SAAS,GAAG;AACZ;AACA;AACA;AACA;AACA,gBAAgB,wDAAqB,kCAAkC,gDAAa;AACpF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,sDAAmB;AAC5C,KAAK;AACL","sources":["webpack://ts-webpack/./src/data.ts","webpack://ts-webpack/./src/realm.ts","webpack://ts-webpack/./src/util.ts","webpack://ts-webpack/webpack/bootstrap","webpack://ts-webpack/webpack/runtime/define property getters","webpack://ts-webpack/webpack/runtime/hasOwnProperty shorthand","webpack://ts-webpack/webpack/runtime/make namespace object","webpack://ts-webpack/./src/index.ts"],"sourcesContent":["export class Data {\r\n    static setup(callback) {\r\n        let loadList = [\r\n            { propertyName: 'content', url: 'content.json', loaded: false },\r\n            { propertyName: 'words', url: 'words.json', loaded: false },\r\n            {\r\n                propertyName: 'placeNameParts',\r\n                url: 'lang/places.json',\r\n                loaded: false\r\n            },\r\n            {\r\n                propertyName: 'riverNameParts',\r\n                url: 'lang/rivers.json',\r\n                loaded: false\r\n            },\r\n            {\r\n                propertyName: 'tributaryNameParts',\r\n                url: 'lang/tributaries.json',\r\n                loaded: false\r\n            },\r\n            {\r\n                propertyName: 'faunaNameParts',\r\n                url: 'lang/fauna.json',\r\n                loaded: false\r\n            },\r\n            {\r\n                propertyName: 'floraNameParts',\r\n                url: 'lang/flora.json',\r\n                loaded: false\r\n            },\r\n            {\r\n                propertyName: 'rulersNameParts',\r\n                url: 'lang/rulers.json',\r\n                loaded: false\r\n            },\r\n            {\r\n                propertyName: 'personNameParts',\r\n                url: 'lang/persons.json',\r\n                loaded: false\r\n            }\r\n        ];\r\n        loadList.forEach((item) => {\r\n            const url = `./assets/data/${item.url}`;\r\n            fetch(url)\r\n                .then((response) => {\r\n                return response.json();\r\n            })\r\n                .then((loadedContent) => {\r\n                Object.getPrototypeOf(Data)[item.propertyName] =\r\n                    loadedContent;\r\n                item.loaded = true;\r\n                console.log(`Loaded ${item.url}`);\r\n                if (loadList.every((t) => {\r\n                    return t.loaded;\r\n                })) {\r\n                    Data.parse();\r\n                    callback();\r\n                }\r\n            });\r\n        });\r\n    }\r\n    static parse() {\r\n        const u = Data.content;\r\n        Data.biomes = u.biomes;\r\n        Data.directions = u.directions;\r\n        Data.images = u.images;\r\n        Data.governmentRanks = u.governmentRanks;\r\n        Data.sigils = u.sigils;\r\n        Data.sizes = u.sizes;\r\n        Data.seasonDescriptors = u.seasons;\r\n        Data.parentEntityDescriptorsBefore = u.parentEntities.descriptorsBefore;\r\n        Data.parentEntityDescriptorsAfter = u.parentEntities.descriptorsAfter;\r\n        Data.parentEntityGovernments = u.parentEntities.governments;\r\n    }\r\n}\r\n","import { Data } from './data';\r\nimport { Util } from './util';\r\nexport class Realm {\r\n    constructor() {\r\n        this.name = 'oldmarch';\r\n        this.adj = 'oldmarch';\r\n        this.capitalCityName = 'highbridge';\r\n        this.sizeIndex = 0;\r\n        this.size = 'small';\r\n        this.governmentRank = 'territory';\r\n        this.leaderTitle = 'lord';\r\n        this.parentEntityName = 'the empire';\r\n        this.parentEntityAdj = 'imperial';\r\n        this.directionWithinParentEntity = 'south';\r\n        this.directionAdjWithinParentEntity = 'south';\r\n        this.temperature = 'temperate';\r\n        this.humidity = 'wet';\r\n        this.seasonSummer = ['long', 'harsh'];\r\n        this.seasonWinter = ['long', 'mild'];\r\n        this.biomes = [];\r\n        this.rivers = [];\r\n        this.tributaries = [];\r\n        this.coastal = false;\r\n        this.sigilName = 'dove';\r\n        this.sigilIcon = 'dove';\r\n        this.sigilMeaning = 'peace';\r\n        this.sigilPresentOnHeraldry = false;\r\n        this.determineParentEntity();\r\n        this.determineDirection();\r\n        this.determineSize();\r\n        this.determineGovernmentRank();\r\n        this.determineClimate();\r\n        this.determineBiomes();\r\n        this.determineRivers();\r\n        this.determineSigil();\r\n        this.determineHeraldry();\r\n    }\r\n    determineParentEntity() {\r\n        let arr = ['the'];\r\n        if (Util.rand() < 0.8) {\r\n            let firstDescriptor = Util.randomValue(Data.parentEntityDescriptorsBefore);\r\n            arr.push(firstDescriptor);\r\n            if (Util.rand() < 0.2) {\r\n                let secondDescriptor = Util.randomValue(Data.parentEntityDescriptorsBefore);\r\n                if (secondDescriptor != firstDescriptor)\r\n                    arr.push(secondDescriptor);\r\n            }\r\n        }\r\n        let government = Util.randomValue(Data.parentEntityGovernments);\r\n        this.parentEntityName = government.noun;\r\n        this.parentEntityAdj = government.adj;\r\n        arr.push(this.parentEntityName);\r\n        if (Util.rand() < 0.1) {\r\n            arr.push(Util.randomValue(Data.parentEntityDescriptorsAfter));\r\n        }\r\n        this.parentEntityName = arr.join(' ');\r\n    }\r\n    determineDirection() {\r\n        const dir = Util.randomValue(Data.directions);\r\n        this.directionWithinParentEntity = dir.noun;\r\n        this.directionAdjWithinParentEntity = dir.adj;\r\n        // 40% chance to be coastal, 0% if location is middle\r\n        this.coastal =\r\n            Util.rand() < 0.4 && this.directionWithinParentEntity != 'middle';\r\n    }\r\n    determineSize() {\r\n        this.sizeIndex = Math.floor(Util.rand() * Data.sizes.length);\r\n        this.size = Data.sizes[this.sizeIndex];\r\n    }\r\n    determineGovernmentRank() {\r\n        let govt;\r\n        do {\r\n            govt = Util.randomValue(Data.governmentRanks);\r\n        } while (!govt.size.includes(this.sizeIndex));\r\n        this.governmentRank = govt.rank;\r\n        this.leaderTitle = govt.ruler;\r\n    }\r\n    determineSigil() {\r\n        let sigil = Util.randomValue(Data.sigils);\r\n        this.sigilName = sigil.name;\r\n        this.sigilIcon = sigil.icon;\r\n        this.sigilMeaning = Util.randomValue(sigil.meanings);\r\n        this.sigilPresentOnHeraldry = Util.rand() < 0.2;\r\n    }\r\n    determineHeraldry() {\r\n        // Choose heraldry based on biomes and animals among other things\r\n    }\r\n    determineClimate() {\r\n        // Choose geography and climate based on the direction\r\n        if (this.directionWithinParentEntity.includes('north')) {\r\n            this.temperature = 'cold';\r\n        }\r\n        else if (this.directionWithinParentEntity.includes('south')) {\r\n            this.temperature = 'warm';\r\n        }\r\n        else {\r\n            this.temperature = 'temperate';\r\n        }\r\n        this.humidity = Util.randomValue(['wet', 'dry']);\r\n        if (this.coastal) {\r\n            this.humidity = 'wet';\r\n        }\r\n        // Description of winter\r\n        this.seasonWinter = [];\r\n        const winter = Data.seasonDescriptors.winter;\r\n        let availableWinterDescriptors = winter[this.humidity].concat(winter[this.temperature]);\r\n        for (let i = 0; i < 2; i++) {\r\n            const d = Util.randomValue(availableWinterDescriptors);\r\n            this.seasonWinter.push(d);\r\n            availableWinterDescriptors = Util.arrayRemove(availableWinterDescriptors, d);\r\n            if (Util.rand() < 0.5)\r\n                break;\r\n        }\r\n        // Description of summer\r\n        this.seasonSummer = [];\r\n        const summer = Data.seasonDescriptors.summer;\r\n        let availableSummerDescriptors = summer[this.humidity].concat(summer[this.temperature]);\r\n        for (let i = 0; i < 2; i++) {\r\n            const d = Util.randomValue(availableSummerDescriptors);\r\n            if (this.seasonWinter.includes(d)) {\r\n                continue;\r\n            }\r\n            this.seasonSummer.push(d);\r\n            availableSummerDescriptors = Util.arrayRemove(availableSummerDescriptors, d);\r\n            if (Util.rand() < 0.5)\r\n                break;\r\n        }\r\n    }\r\n    determineBiomes() {\r\n        // mountain | boreal-forest | temperate-forest | grassland | tundra\r\n        let availableBiomes = Data.biomes.filter((str) => {\r\n            switch (this.humidity) {\r\n                case 'dry':\r\n                    // Dry? Remove boreal-forest and temperate-forest\r\n                    return ['boreal-forest', 'temperate-forest'].includes(str);\r\n                    break;\r\n                case 'wet':\r\n                    // Wet? Remove grassland and tundra\r\n                    return ['grassland', 'tundra'].includes(str);\r\n                    break;\r\n            }\r\n            return true;\r\n        });\r\n        // Add the primary biome, reroll once if mountains\r\n        let b = Util.randomValue(availableBiomes);\r\n        if (b == 'mountains')\r\n            b = Util.randomValue(availableBiomes);\r\n        availableBiomes = Util.arrayRemove(availableBiomes, b);\r\n        let availableSizeIndex = Data.sizes.indexOf(this.size) * 2;\r\n        let sizeIndex = Math.floor(Util.rand() * availableSizeIndex);\r\n        availableSizeIndex -= sizeIndex;\r\n        let primaryBiome = {\r\n            type: b,\r\n            size: Data.sizes[Math.max(1, sizeIndex)],\r\n            direction: Util.randomValue(Data.directions)\r\n        };\r\n        this.biomes.push(primaryBiome);\r\n        if (Util.rand() < 0.6) {\r\n            // Choose a direction that isn't the same direction as the primary Biome's direction\r\n            // Also cannot be a combined direction like north-east or south-west, must be one of the four cardinal directions or 'middle'\r\n            let secondaryDirection;\r\n            do {\r\n                secondaryDirection = Util.randomValue(Data.directions);\r\n            } while (secondaryDirection.noun == primaryBiome.direction.noun ||\r\n                secondaryDirection.noun.includes('-'));\r\n            let secondaryBiome = {\r\n                type: Util.randomValue(availableBiomes),\r\n                size: Data.sizes[Math.floor(Util.rand() * availableSizeIndex)],\r\n                direction: secondaryDirection\r\n            };\r\n            // Add a second biome\r\n            this.biomes.push(secondaryBiome);\r\n        }\r\n    }\r\n    determineRivers() {\r\n        let riverMinMax = [0, 0];\r\n        switch (this.humidity) {\r\n            case 'dry':\r\n                riverMinMax = [0, 1];\r\n                break;\r\n            case 'temperate':\r\n                riverMinMax = [1, 4];\r\n                break;\r\n            case 'wet':\r\n                riverMinMax = [3, 5];\r\n                break;\r\n        }\r\n        let riverCount = Math.floor(Util.rand() * (riverMinMax[1] - riverMinMax[0]) + riverMinMax[0]);\r\n        // For small realms (less than 3 on the sizeIndex) there shouldn't be more than two rivers passing through\r\n        if (this.sizeIndex < 3) {\r\n            riverCount = Math.min(riverCount, 2);\r\n        }\r\n        console.log(`Size index: ${this.sizeIndex}`);\r\n        // Add rivers\r\n        for (let i = 0; i < riverCount; i++) {\r\n            // If the realm contains a mountain biome, rivers should flow from it\r\n            let flowsFrom = Util.randomValue(Data.directions);\r\n            // If the realm contains a coast, rivers should flow to it\r\n            let flowsTo = Util.randomValue(Data.directions);\r\n            let riverName = this.determineRiverName();\r\n            let tributaries = this.determineTributaries(riverName);\r\n            let river = {\r\n                name: riverName,\r\n                flowsTo: flowsTo,\r\n                flowsFrom: flowsFrom,\r\n                tributaries: tributaries,\r\n                stem: null\r\n            };\r\n            this.rivers.push(river);\r\n            this.tributaries.push(...tributaries);\r\n        }\r\n        let arr = [];\r\n        for (let i = 0; i < 20; i++)\r\n            arr.push(Util.readWord(this.determineRiverName()));\r\n        console.log(arr.join(', '));\r\n    }\r\n    determineTributaries(riverName) {\r\n        let tributaries = [];\r\n        const tributaryCount = Util.randomValue([0, 2]);\r\n        for (let i = 0; i < tributaryCount; i++) {\r\n            // tributaries.push(t);\r\n        }\r\n        return tributaries;\r\n    }\r\n    determineRiverName() {\r\n        const tags = ['any'];\r\n        // Determine root\r\n        let validRoots = Data.riverNameParts\r\n            .concat(Data.faunaNameParts)\r\n            .concat(Data.floraNameParts)\r\n            .concat(Data.rulersNameParts)\r\n            .filter((namePart) => {\r\n            // Root cannot be used by another river\r\n            // Have at least one point as a root name part\r\n            // Have at least one matching tag\r\n            return (this.rivers.every((river) => river.name.root.name != namePart.name) &&\r\n                namePart.asRoot > 0 &&\r\n                namePart.tags.some((tag) => tags.includes(tag)));\r\n        });\r\n        let root = Util.randomValue(validRoots);\r\n        if (root.variations) {\r\n            root.variations.push(root.name);\r\n            root.name = Util.randomValue(root.variations);\r\n        }\r\n        // Determine suffix\r\n        let validSuffixes = Data.riverNameParts.filter((namePart) => {\r\n            // Have at least one point as a suffix name part\r\n            // Have at least one matching tag\r\n            return (namePart.asSuffix > 0 && namePart.tags.some((tag) => tags.includes(tag)));\r\n        });\r\n        let riverName;\r\n        do {\r\n            let suffix = Util.randomValue(validSuffixes);\r\n            if (suffix.variations) {\r\n                suffix.variations.push(suffix.name);\r\n                suffix.name = Util.randomValue(suffix.variations);\r\n            }\r\n            riverName = { root: root, suffix: suffix };\r\n        } while (!isRiverNameValid(riverName));\r\n        function isRiverNameValid(r) {\r\n            let valid = true;\r\n            if (Util.endsWithVowel(r.root.name) &&\r\n                Util.startsWithVowel(r.suffix.name)) {\r\n                valid = false;\r\n            }\r\n            return valid;\r\n        }\r\n        return riverName;\r\n    }\r\n}\r\n","import { Data } from './data';\r\nexport class Util {\r\n    static generateSeed() {\r\n        let arr = [];\r\n        for (let i = 0; i < 3; i++) {\r\n            arr.push(Util.randomValue(Data.words, false));\r\n        }\r\n        Util.seed = arr.join('-');\r\n        Util.seedRandomNumberGenerator();\r\n    }\r\n    static seedRandomNumberGenerator() {\r\n        let h = 1779033703 ^ Util.seed.length;\r\n        for (var i = 0; i < Util.seed.length; i++) {\r\n            h = Math.imul(h ^ Util.seed.charCodeAt(i), 3432918353);\r\n            h = (h << 13) | (h >>> 19);\r\n        }\r\n        Util.m_w = (123456789 + h) & Util.mask;\r\n        Util.m_z = (987654321 - h) & Util.mask;\r\n    }\r\n    static rand() {\r\n        Util.m_z = (36969 * (Util.m_z & 65535) + (Util.m_z >> 16)) & Util.mask;\r\n        Util.m_w = (18000 * (Util.m_w & 65535) + (Util.m_w >> 16)) & Util.mask;\r\n        let result = ((Util.m_z << 16) + (Util.m_w & 65535)) >>> 0;\r\n        return result / 4294967296;\r\n    }\r\n    static arrayRemove(arr, elementToRemove) {\r\n        return arr.filter(function (element) {\r\n            return element != elementToRemove;\r\n        });\r\n    }\r\n    // Returns a random value from an array\r\n    static randomValue(u, seeded = true) {\r\n        return seeded\r\n            ? u[Math.floor(Util.rand() * u.length)]\r\n            : u[Math.floor(Math.random() * u.length)];\r\n    }\r\n    // Returns 'a' or 'an' if str's first char is a consonant or a vowel\r\n    static aOrAn(str) {\r\n        return Util.startsWithVowel(str) ? 'an' : 'a';\r\n    }\r\n    // Returns true if the string starts with a vowel\r\n    static startsWithVowel(str) {\r\n        const regex = new RegExp('^[aeiou].*', 'i');\r\n        return regex.test(str);\r\n    }\r\n    // Returns true if the string starts with a vowel\r\n    static endsWithVowel(str) {\r\n        const regex = new RegExp('.*[aeiou]$', 'i');\r\n        return regex.test(str);\r\n    }\r\n    // Returns a string joining an array of at least two entries\r\n    // with commas and the word 'and' between the last two entries\r\n    static joinArrayWithAnd(arr) {\r\n        const last = arr.pop();\r\n        if (arr.length == 1) {\r\n            return arr[0] + ' and ' + last;\r\n        }\r\n        let str = arr.join(', ');\r\n        str += ', and ' + last;\r\n        return str;\r\n    }\r\n    // Tweet a realm\r\n    static shareByTweet(realm) {\r\n        let tweet = `Explore ${Util.capitalize(realm.name)}, a ${realm.size} ${realm.parentEntityAdj} ${realm.governmentRank}.`;\r\n        window.open('https://twitter.com/intent/tweet?url=' +\r\n            window.location.href +\r\n            '&text=' +\r\n            tweet, '_blank');\r\n    }\r\n    // Capitalize first letter\r\n    static capitalize(str) {\r\n        return str.charAt(0).toUpperCase() + str.substring(1);\r\n    }\r\n    // Combines word parts into a string\r\n    static readWord(word) {\r\n        return word.root.name + word.suffix.name;\r\n    }\r\n    // Returns any number lower than 20 as a word ('one', 'two', ... 'nineteen')\r\n    static wordFromNumber(n) {\r\n        const words = [\r\n            'zero',\r\n            'one',\r\n            'two',\r\n            'three',\r\n            'four',\r\n            'five',\r\n            'six',\r\n            'seven',\r\n            'eight',\r\n            'nine',\r\n            'ten',\r\n            'eleven',\r\n            'twelve',\r\n            'thirteen',\r\n            'fourteen',\r\n            'fifteen',\r\n            'sixteen',\r\n            'seventeen',\r\n            'eighteen',\r\n            'nineteen'\r\n        ];\r\n        return n < words.length ? words[n] : n.toString();\r\n    }\r\n}\r\nUtil.m_w = 123456789;\r\nUtil.m_z = 987654321;\r\nUtil.mask = 4294967295;\r\n","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","import { Util } from './util';\r\nimport { Data } from './data';\r\nimport { Realm } from './realm';\r\n/**\r\n * Hint: Use 'npm run build' from console to compile + watch the TS code on save\r\n */\r\n// Handle start button\r\nconst btnStart = document.getElementById('btnStart');\r\nbtnStart.addEventListener('click', generateSeedAndStart);\r\n// Handle tweet button\r\nconst btnShareTwitter = document.getElementById('btnShareTwitter');\r\nbtnShareTwitter.addEventListener('click', () => {\r\n    Util.shareByTweet(realm);\r\n});\r\n// Load data\r\nData.setup(() => {\r\n    // Does the url contain a seed (query)?\r\n    // www.google.com?foo\r\n    //    -> foo\r\n    // www.google.com?bar#\r\n    //    -> bar\r\n    const url = window.location.href;\r\n    const arr = url.match(/\\?([a-z0-9,-]+)/);\r\n    if (arr && arr.length > 1) {\r\n        Util.seed = arr[1];\r\n        start();\r\n    }\r\n    else {\r\n        generateSeedAndStart();\r\n    }\r\n});\r\n// Initialize variables\r\nlet realm;\r\nfunction generateSeedAndStart() {\r\n    Util.generateSeed();\r\n    let url = window.location.href;\r\n    url = url.substring(0, url.indexOf('?'));\r\n    if (window.location.href)\r\n        window.location.replace(url + '?' + Util.seed);\r\n}\r\n// Start the generation process\r\nfunction start() {\r\n    Util.seedRandomNumberGenerator();\r\n    realm = new Realm();\r\n    updateView();\r\n    // Delay intro animations\r\n    const sectionEls = document.querySelectorAll('.container');\r\n    sectionEls.forEach((node, index) => {\r\n        const el = node;\r\n        setTimeout(() => {\r\n            el.classList.add('fade-in');\r\n        }, 250 * index);\r\n    });\r\n}\r\nfunction updateView() {\r\n    // Choose a photo for the hero\r\n    const heroEl = document.getElementById('hero');\r\n    heroEl.setAttribute('style', `background-image: linear-gradient(rgba(0, 0, 0, 0.5), rgba(0, 0, 0, 0.5)), url(${determineHeroImageUrl()})`);\r\n    // Blurbs\r\n    applyBiomesBlurb();\r\n    applyRiversBlurb();\r\n    toggleVisibility('sigil-present-on-heraldry', realm.sigilPresentOnHeraldry);\r\n    // Words\r\n    applyText('name', realm.name);\r\n    applyText('government-rank', realm.governmentRank);\r\n    applyText('parent-entity', realm.parentEntityName);\r\n    applyText('parent-entity-adj', realm.parentEntityAdj);\r\n    applyText('direction-within-parent-entity', realm.directionWithinParentEntity);\r\n    applyText('direction-adj-within-parent-entity', realm.directionAdjWithinParentEntity);\r\n    applyText('capital-city', realm.capitalCityName);\r\n    applyText('sigil-name', realm.sigilName);\r\n    applyText('sigil-meaning', realm.sigilMeaning);\r\n    applyText('size', realm.size);\r\n    applyText('climate', realm.temperature);\r\n    applyText('season-summer', realm.seasonSummer.join(', '));\r\n    applyText('season-winter', realm.seasonWinter.join(', '));\r\n    applyIcon('sigil', realm.sigilIcon);\r\n    // Utility\r\n    replaceNumbers();\r\n}\r\nfunction determineHeroImageUrl() {\r\n    // Todo use realm information to determine the image\r\n    return Util.randomValue(Data.images);\r\n}\r\nfunction applyText(query, text) {\r\n    const els = document.querySelectorAll('span.' + query);\r\n    els.forEach((node) => {\r\n        const el = node;\r\n        if (el.classList.contains('prepend-article')) {\r\n            el.textContent = Util.aOrAn(text) + ' ' + text;\r\n        }\r\n        else {\r\n            el.textContent = text;\r\n        }\r\n    });\r\n}\r\nfunction toggleVisibility(query, visible) {\r\n    const els = document.querySelectorAll('span.' + query);\r\n    els.forEach((node) => {\r\n        const el = node;\r\n        if (visible) {\r\n            el.classList.remove('hidden');\r\n        }\r\n        else {\r\n            el.classList.add('hidden');\r\n        }\r\n    });\r\n}\r\nfunction applyIcon(query, icon) {\r\n    const els = document.querySelectorAll('i.' + query);\r\n    els.forEach((node) => {\r\n        const el = node;\r\n        // Remove the previous icon\r\n        el.classList.forEach((className) => {\r\n            let text = '';\r\n            if (className.includes('fa-') && className !== 'fa-2x') {\r\n                el.classList.remove(className);\r\n            }\r\n        });\r\n        el.classList.add('fa-' + icon);\r\n    });\r\n}\r\nfunction applyBiomesBlurb() {\r\n    let text = '';\r\n    if (realm.biomes.length == 1) {\r\n        let b = realm.biomes[0];\r\n        text = `<span class=\"name\"></span> is made up of ${b.type}.`;\r\n    }\r\n    else if (realm.biomes.length == 2) {\r\n        let b1 = realm.biomes[0];\r\n        let b2 = realm.biomes[1];\r\n        text = `The ecoregions of <span class=\"name\"></span> consist mostly of ${b1.type} with a ${b2.size} ${b2.type} region in the ${b2.direction.noun}.`;\r\n    }\r\n    const el = document.querySelector('.biomes-blurb');\r\n    el.innerHTML = text;\r\n}\r\nfunction applyRiversBlurb() {\r\n    let text = '';\r\n    if (realm.rivers.length == 0) {\r\n        text = `No notable rivers pass through <span class=\"name\"></span>.`;\r\n    }\r\n    else if (realm.rivers.length == 1) {\r\n        let r = realm.rivers[0];\r\n        text = `The main river that flows through <span class=\"name\"></span> is the <span class=\"capitalized\">${Util.readWord(r.name)}</span>. The <span class=\"capitalized\">${Util.readWord(r.name)}</span> starts in the ${r.flowsFrom.noun} and flows toward the ${r.flowsTo.noun}.`;\r\n    }\r\n    else {\r\n        text = `<span class=\"word-number capitalized\">${realm.rivers.length}</span> rivers pass through <span class=\"name\"></span>: ${Util.joinArrayWithAnd(realm.rivers.map((river) => {\r\n            return `the <span class=\"capitalized\">${Util.readWord(river.name)}</span>`;\r\n        }))}.`;\r\n    }\r\n    if (realm.tributaries.length > 0) {\r\n        text +=\r\n            '<br>Notable tributaries include the ' +\r\n                Util.joinArrayWithAnd(realm.tributaries.map((river) => Util.readWord(river.name)));\r\n    }\r\n    const el = document.querySelector('.rivers-blurb');\r\n    el.innerHTML = text;\r\n}\r\nfunction replaceNumbers() {\r\n    const els = document.querySelectorAll('.word-number');\r\n    els.forEach((node) => {\r\n        const el = node;\r\n        el.textContent = Util.wordFromNumber(Number.parseInt(el.textContent ? el.textContent : '0'));\r\n    });\r\n}\r\n"],"names":[],"sourceRoot":""}