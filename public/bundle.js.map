{"version":3,"file":"bundle.js","mappings":";;;;;;;;;;;;;;;;AAA8B;AACJ;AACX;AACf;AACA;AACA;AACA,wBAAwB,4DAAyB;AACjD;AACA;AACA,kBAAkB,iEAAwB;AAC1C;AACA;AACA;AACA,uCAAuC,wDAAqB;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,kCAAkC,yDAAgB;AAClD;AACA,0BAA0B,iEAAwB,CAAC,+CAAY;AAC/D;AACA;AACA;;;;;;;;;;;;;;;AC5BO;AACP;AACA;AACA,cAAc,6DAA6D;AAC3E,cAAc,yDAAyD;AACvE;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC,SAAS;AAClD;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,sCAAsC,SAAS;AAC/C;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;;;;;;;;;;;;;;;;;;AC/F0B;AACI;AACJ;AACnB;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,kDAAS;AACrB,kCAAkC,yDAAgB,CAAC,qEAAkC;AACrF;AACA,gBAAgB,kDAAS;AACzB,uCAAuC,yDAAgB,CAAC,qEAAkC;AAC1F;AACA;AACA;AACA;AACA,yBAAyB,yDAAgB,CAAC,+DAA4B;AACtE;AACA;AACA;AACA,YAAY,kDAAS;AACrB,qBAAqB,yDAAgB,CAAC,oEAAiC;AACvE;AACA;AACA;AACA;AACA,oBAAoB,yDAAgB,CAAC,kDAAe;AACpD;AACA;AACA;AACA;AACA;AACA,YAAY,kDAAS;AACrB;AACA;AACA;AACA;AACA;AACA,sCAAsC,yDAAgB,CAAC,kDAAe;AACtE;AACA;AACA;AACA;AACA;AACA,oCAAoC,kDAAS,KAAK,oDAAiB;AACnE,oBAAoB,6CAAU;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,yDAAgB,CAAC,uDAAoB;AACxD,UAAU;AACV;AACA;AACA;AACA;AACA;AACA,oBAAoB,yDAAgB,CAAC,8CAAW;AAChD;AACA;AACA,4BAA4B,yDAAgB;AAC5C;AACA;AACA;AACA;AACA,uBAAuB,iEAAwB,CAAC,kDAAe;AAC/D;AACA,uBAAuB,wDAAqB;AAC5C,qBAAqB,iEAAwB;AAC7C,uBAAuB,wDAAqB;AAC5C,qBAAqB,iEAAwB;AAC7C,qDAAqD,kDAAS;AAC9D,wBAAwB,6CAAI;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,yDAAgB;AACxC;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,gEAA6B;AACpD;AACA,wBAAwB,OAAO;AAC/B,sBAAsB,yDAAgB;AACtC;AACA,yCAAyC,yDAAgB;AACzD;AACA;AACA,gBAAgB,kDAAS;AACzB;AACA;AACA;AACA;AACA,uBAAuB,gEAA6B;AACpD;AACA,wBAAwB,OAAO;AAC/B,sBAAsB,yDAAgB;AACtC;AACA;AACA;AACA;AACA,yCAAyC,yDAAgB;AACzD,gBAAgB,kDAAS;AACzB;AACA;AACA;AACA;AACA;AACA,8BAA8B,qDAAkB;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,gBAAgB,yDAAgB;AAChC;AACA;AACA,gBAAgB,yDAAgB;AAChC,0BAA0B,yDAAgB;AAC1C,iCAAiC,qDAAkB;AACnD,mCAAmC,kDAAS;AAC5C;AACA;AACA;AACA,kBAAkB,6CAAU;AAC5B,uBAAuB,yDAAgB,CAAC,kDAAe;AACvD;AACA;AACA;AACA,YAAY,kDAAS;AACrB;AACA;AACA;AACA;AACA,qCAAqC,yDAAgB,CAAC,kDAAe;AACrE,cAAc;AACd;AACA;AACA,sBAAsB,yDAAgB;AACtC,sBAAsB,6CAAU,YAAY,kDAAS;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,kDAAS;AAC7C;AACA;AACA;AACA;AACA;AACA,wBAAwB,gBAAgB;AACxC;AACA;AACA;AACA;AACA,iCAAiC,kDAAS;AAC1C;AACA;AACA;AACA;AACA,4BAA4B,yDAAgB,CAAC,kDAAe;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,kDAAS;AACvC;AACA;AACA;AACA;AACA;AACA,8BAA8B,yDAAgB,CAAC,kDAAe;AAC9D,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,QAAQ;AAChC,qBAAqB,sDAAa;AAClC;AACA;AACA;AACA,0CAA0C,kDAAS;AACnD,wBAAwB,oBAAoB;AAC5C;AACA,gCAAgC,kDAAS;AACzC,yBAAyB,yDAAgB,CAAC,kDAAe;AACzD;AACA,2BAA2B,yDAAgB,CAAC,kDAAe;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,sDAAa,eAAe,sDAAa;AACzD,mCAAmC,yDAAgB,CAAC,iEAA8B;AAClF;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA,wDAAwD;AACxD;AACA;AACA;AACA;AACA,sBAAsB,kDAAS;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,6DACN,CAAC,sDAAmB;AACvC,oBAAoB,sDAAmB;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,mBAAmB,iEAAwB;AAC3C;AACA;AACA,wBAAwB,yDAAgB;AACxC;AACA;AACA;AACA;AACA,4BAA4B,6DAA0B;AACtD;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,yBAAyB,iEAAwB;AACjD;AACA;AACA,8BAA8B,yDAAgB;AAC9C;AACA,0BAA0B;AAC1B,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA,gEAAgE,YAAY;AAC5E;AACA;AACA;AACA;AACA,YAAY,2DAAkB;AAC9B,YAAY,6DAAoB;AAChC;AACA;AACA;AACA;AACA;AACA,4BAA4B,sDAAa;AACzC,oCAAoC,sDAAa;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,6DACN,CAAC,uDAAoB;AACxC,oBAAoB,sDAAmB;AACvC,oBAAoB,sDAAmB;AACvC;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,mCAAmC,EAAE,iEAAwB;AAC7D;AACA;AACA,wBAAwB,yDAAgB;AACxC;AACA;AACA;AACA;AACA,4BAA4B,6DAA0B;AACtD;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,yBAAyB,iEAAwB;AACjD;AACA;AACA,8BAA8B,yDAAgB;AAC9C;AACA,+BAA+B;AAC/B,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;AChc8B;AACf;AACf;AACA;AACA,sDAAsD;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,qCAAqC;AACnD,cAAc,4DAA4D;AAC1E,cAAc,iEAAiE;AAC/E,cAAc,2DAA2D;AACzE,cAAc,sCAAsC;AACpD,cAAc,0DAA0D;AACxE,cAAc,+DAA+D;AAC7E,cAAc,yDAAyD;AACvE,cAAc,2CAA2C;AACzD,cAAc,iEAAiE;AAC/E,cAAc,4CAA4C;AAC1D,cAAc;AACd;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,cAAc,qCAAqC;AACnD,cAAc,yDAAyD;AACvE,cAAc,8DAA8D;AAC5E,cAAc,wDAAwD;AACtE,cAAc,sCAAsC;AACpD,cAAc,6DAA6D;AAC3E,cAAc,kEAAkE;AAChF,cAAc,4DAA4D;AAC1E,cAAc,2CAA2C;AACzD,cAAc,8DAA8D;AAC5E,cAAc,4CAA4C;AAC1D,cAAc;AACd;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,wBAAwB,OAAO;AAC/B,sCAAsC,6CAAU;AAChD;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,sBAAsB;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,+BAA+B,gDAAgD,MAAM,YAAY,EAAE,uBAAuB,EAAE,qBAAqB;AACjJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;UC9LA;UACA;;UAEA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;;UAEA;UACA;;UAEA;UACA;UACA;;;;;WCtBA;WACA;WACA;WACA;WACA,yCAAyC,wCAAwC;WACjF;WACA;WACA;;;;;WCPA;;;;;WCAA;WACA;WACA;WACA,uDAAuD,iBAAiB;WACxE;WACA,gDAAgD,aAAa;WAC7D;;;;;;;;;;;;;;ACN0B;AACI;AACE;AAChC;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,4DAAmB;AACvC;AACA;AACA;AACA,IAAI,4DAAmB;AACvB;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qDAAqD,kDAAS;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,IAAI,sDAAsD,OAAO;AAClF;AACA,4CAA4C,KAAK;AACjD;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,YAAY,kDAAS;AACrB,cAAc,sDAAa;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA,IAAI,0DAAiB;AACrB,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,8BAA8B;AAC9B,SAAS;AACT,QAAQ,sDAAa,CAAC,sDAAa;AACnC,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6CAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,kDAAS;AACjB;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA,IAAI,0DAAiB;AACrB;AACA;AACA;AACA,4CAA4C,kDAAS;AACrD;AACA;AACA;AACA,IAAI,uEAA8B;AAClC,gBAAgB,yCAAK;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,sDAAa;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,KAAK;AACL;AACA;AACA;AACA;AACA,oBAAoB,QAAQ;AAC5B,kBAAkB,yDAAgB,CAAC,6CAAU;AAC7C,uBAAuB,KAAK,eAAe,sDAAa,WAAW;AACnE;AACA;AACA;AACA;AACA;AACA,mHAAmH,wBAAwB;AAC3I;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,sDAAa;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,yDACT;AACf;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA,kBAAkB,yDAAgB;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,mDAAU;AACvC;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,sEAAsE,QAAQ;AAC9E;AACA;AACA;AACA;AACA,iFAAiF,SAAS,SAAS,SAAS,EAAE,SAAS,gBAAgB,kBAAkB;AACzJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gHAAgH,sDAAa,SAAS;AACtI;AACA,iDAAiD,sDAAa,SAAS;AACvE;AACA,qCAAqC,iBAAiB;AACtD;AACA;AACA,gEAAgE,kBAAkB;AAClF;AACA;AACA;AACA,mDAAmD,eAAe;AAClE;AACA;AACA,4CAA4C,eAAe;AAC3D;AACA;AACA;AACA;AACA,wDAAwD,oBAAoB,0DAA0D,8DAAqB;AAC3J,oDAAoD,sDAAa,aAAa;AAC9E,SAAS,GAAG;AACZ;AACA;AACA;AACA;AACA,gBAAgB,8DAAqB;AACrC;AACA,wDAAwD,OAAO,mCAAmC,sDAAa,iBAAiB;AAChI,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,4DAAmB;AAC5C,KAAK;AACL","sources":["webpack://ts-webpack/./src/Coat.ts","webpack://ts-webpack/./src/Data.ts","webpack://ts-webpack/./src/Realm.ts","webpack://ts-webpack/./src/Util.ts","webpack://ts-webpack/webpack/bootstrap","webpack://ts-webpack/webpack/runtime/define property getters","webpack://ts-webpack/webpack/runtime/hasOwnProperty shorthand","webpack://ts-webpack/webpack/runtime/make namespace object","webpack://ts-webpack/./src/index.ts"],"sourcesContent":["import { Data } from './Data';\r\nimport Util from './Util';\r\nexport default class Coat {\r\n    constructor(ordinary, tinctures) {\r\n        this.ordinary = ordinary;\r\n        this.tinctures = tinctures;\r\n        const layouts = Data.chargeLayouts.filter((l) => ordinary.layouts.some((m) => m.name == l.name));\r\n        this.chargeLayout =\r\n            ordinary.layouts.length > 0\r\n                ? Util.randomWeightedValue(layouts, (l) => l.weight)\r\n                : null;\r\n        if (this.chargeLayout) {\r\n            // Determine the charge's tincture\r\n            const availableTinctures = Data.tinctures.filter((t) => {\r\n                // Heraldic rule: Never put a color on another color\r\n                // and never put a metal on top of another metal\r\n                const tinctureOverlapIndexes = ordinary.layouts.find((l) => l.name == this.chargeLayout.name).overlap;\r\n                if (tinctureOverlapIndexes.length > 0) {\r\n                    const overlapTincture = tinctures[tinctureOverlapIndexes[0]];\r\n                    return t.type != overlapTincture.type && !tinctures.includes(t);\r\n                }\r\n                return false;\r\n            });\r\n            this.chargeTincture = Util.randomValue(availableTinctures);\r\n            // Pick a charge\r\n            this.charge = Util.randomWeightedValue(Data.charges, (c) => c.weight);\r\n        }\r\n    }\r\n}\r\n","export class Data {\r\n    static setup(callback) {\r\n        let loadList = [\r\n            { propertyName: 'content', url: 'content.json', loaded: false },\r\n            { propertyName: 'words', url: 'words.json', loaded: false },\r\n            {\r\n                propertyName: 'placeNameParts',\r\n                url: 'lang/places.json',\r\n                loaded: false\r\n            },\r\n            {\r\n                propertyName: 'riverNameParts',\r\n                url: 'lang/rivers.json',\r\n                loaded: false\r\n            },\r\n            {\r\n                propertyName: 'tributaryNameParts',\r\n                url: 'lang/tributaries.json',\r\n                loaded: false\r\n            },\r\n            {\r\n                propertyName: 'faunaNameParts',\r\n                url: 'lang/fauna.json',\r\n                loaded: false\r\n            },\r\n            {\r\n                propertyName: 'floraNameParts',\r\n                url: 'lang/flora.json',\r\n                loaded: false\r\n            },\r\n            {\r\n                propertyName: 'rulersNameParts',\r\n                url: 'lang/rulers.json',\r\n                loaded: false\r\n            },\r\n            {\r\n                propertyName: 'personNameParts',\r\n                url: 'lang/persons.json',\r\n                loaded: false\r\n            }\r\n        ];\r\n        loadList.forEach((item) => {\r\n            const url = `./assets/data/${item.url}`;\r\n            fetch(url)\r\n                .then((response) => {\r\n                return response.json();\r\n            })\r\n                .then((loadedContent) => {\r\n                Object.getPrototypeOf(Data)[item.propertyName] =\r\n                    loadedContent;\r\n                item.loaded = true;\r\n                console.log(`Loaded ${item.url}`);\r\n                if (loadList.every((t) => {\r\n                    return t.loaded;\r\n                })) {\r\n                    Data.parse();\r\n                    callback();\r\n                }\r\n            });\r\n        });\r\n    }\r\n    static parse() {\r\n        const u = Data.content;\r\n        Data.biomes = u.biomes;\r\n        Data.directions = u.directions;\r\n        Data.heroImages = u.heroImages.map((heroImage) => {\r\n            heroImage.url = './assets/images/hero_images/' + heroImage.url;\r\n            return heroImage;\r\n        });\r\n        Data.governmentRanks = u.governmentRanks;\r\n        Data.sigils = u.sigils;\r\n        Data.sizes = u.sizes;\r\n        Data.seasonDescriptors = u.seasons;\r\n        Data.parentEntityDescriptorsBefore = u.parentEntities.descriptorsBefore;\r\n        Data.parentEntityDescriptorsAfter = u.parentEntities.descriptorsAfter;\r\n        Data.parentEntityGovernments = u.parentEntities.governments;\r\n        // Apply heraldry\r\n        Data.ordinaries = u.heraldry.ordinaries;\r\n        Data.tinctures = u.heraldry.tinctures;\r\n        Data.chargeLayouts = u.heraldry.layouts;\r\n        Data.charges = u.heraldry.charges;\r\n        // Apply defaults to nameParts\r\n        Data.placeNameParts\r\n            .concat(Data.riverNameParts)\r\n            .concat(Data.tributaryNameParts)\r\n            .concat(Data.faunaNameParts)\r\n            .concat(Data.floraNameParts)\r\n            .concat(Data.rulersNameParts)\r\n            // .concat(Data.personsNameParts)\r\n            .forEach((namePart) => {\r\n            if (!namePart.tagRule) {\r\n                namePart.tagRule = 'OR';\r\n            }\r\n        });\r\n    }\r\n}\r\n","import Coat from './Coat';\r\nimport { Data } from './Data';\r\nimport Util from './Util';\r\nexport class Realm {\r\n    constructor() {\r\n        this.tags = ['any'];\r\n        this.seasonSummer = [];\r\n        this.seasonWinter = [];\r\n        this.biomes = [];\r\n        this.rivers = [];\r\n        this.tributaries = [];\r\n        this.coast = false;\r\n        this.countRiverValidLoop = 0;\r\n        this.determineParentEntity();\r\n        this.determineDirection();\r\n        this.determineSize();\r\n        this.determineGovernmentRank();\r\n        this.determineClimate();\r\n        this.determineBiomes();\r\n        this.determineRivers();\r\n        this.determineSigil();\r\n        this.determineRealmName();\r\n        this.determineCities();\r\n        this.determineCoat();\r\n        // console.log(this.tags);\r\n    }\r\n    determineParentEntity() {\r\n        let arr = ['the'];\r\n        if (Util.rand() < 0.8) {\r\n            let firstDescriptor = Util.randomValue(Data.parentEntityDescriptorsBefore);\r\n            arr.push(firstDescriptor);\r\n            if (Util.rand() < 0.2) {\r\n                let secondDescriptor = Util.randomValue(Data.parentEntityDescriptorsBefore);\r\n                if (secondDescriptor != firstDescriptor)\r\n                    arr.push(secondDescriptor);\r\n            }\r\n        }\r\n        let government = Util.randomValue(Data.parentEntityGovernments);\r\n        this.parentEntityName = government.noun;\r\n        this.parentEntityAdj = government.adj;\r\n        arr.push(this.parentEntityName);\r\n        if (Util.rand() < 0.1) {\r\n            arr.push(Util.randomValue(Data.parentEntityDescriptorsAfter));\r\n        }\r\n        this.parentEntityName = arr.join(' ');\r\n    }\r\n    determineDirection() {\r\n        const dir = Util.randomValue(Data.directions);\r\n        this.directionWithinParentEntity = dir;\r\n        // Add direction tags south-west => south, west\r\n        this.tags.push(...this.directionWithinParentEntity.noun.split('-'));\r\n        // 40% chance to be coastal, 0% if location is middle\r\n        this.coastDirection = this.directionWithinParentEntity;\r\n        if (Util.rand() < 0.4 &&\r\n            this.directionWithinParentEntity.noun != 'middle') {\r\n            this.coast = true;\r\n            while (!this.directionWithinParentEntity.noun\r\n                .split('-')\r\n                .includes(this.coastDirection.noun)) {\r\n                this.coastDirection = Util.randomValue(Data.directions);\r\n            }\r\n            this.tags.push('coast');\r\n        }\r\n    }\r\n    determineSize() {\r\n        this.sizeIndex = Math.floor(Util.rand() * Data.sizes.length);\r\n        this.size = Data.sizes[this.sizeIndex];\r\n        if (this.sizeIndex == 0) {\r\n            this.tags.push('city');\r\n        }\r\n        else {\r\n            this.tags.push('region');\r\n        }\r\n    }\r\n    determineGovernmentRank() {\r\n        let govt;\r\n        do {\r\n            govt = Util.randomValue(Data.governmentRanks);\r\n        } while (!govt.size.includes(this.sizeIndex));\r\n        this.governmentRank = govt.rank;\r\n        this.tags.push(this.governmentRank);\r\n        this.leaderTitle = govt.ruler;\r\n    }\r\n    determineSigil() {\r\n        let sigil = Util.randomValue(Data.sigils);\r\n        this.sigilName = sigil.name;\r\n        this.sigilIcon = sigil.icon;\r\n        this.sigilMeaning = Util.randomValue(sigil.meanings);\r\n    }\r\n    determineCoat() {\r\n        // Choose a coat of arms based on biomes and animals among other things\r\n        // Choose an ordinary using chance as points\r\n        let ordinary = Util.randomWeightedValue(Data.ordinaries, (item) => item.weight);\r\n        // Choose exactly one metal and one color\r\n        const metals = Data.tinctures.filter((t) => t.type == 'metal');\r\n        let tMetal = Util.randomWeightedValue(metals, (item) => item.weight);\r\n        const colors = Data.tinctures.filter((t) => t.type == 'color');\r\n        let tColor = Util.randomWeightedValue(colors, (item) => item.weight);\r\n        let tinctures = [tMetal, tColor].sort((t) => Util.rand() > 0.5 ? 1 : -1);\r\n        this.coat = new Coat(ordinary, tinctures);\r\n        // todo set this correctly\r\n        this.sigilPresentOnHeraldry = false;\r\n    }\r\n    // Choose geography and climate based on the direction\r\n    determineClimate() {\r\n        if (this.directionWithinParentEntity.noun.includes('north')) {\r\n            this.temperature = 'cold';\r\n        }\r\n        else if (this.directionWithinParentEntity.noun.includes('south')) {\r\n            this.temperature = 'warm';\r\n        }\r\n        else {\r\n            this.temperature = 'temperate';\r\n        }\r\n        this.tags.push(this.temperature);\r\n        this.humidity = Util.randomValue(['wet', 'dry']);\r\n        if (this.coast) {\r\n            this.humidity = 'wet';\r\n        }\r\n        this.tags.push(this.humidity);\r\n        // Description of winter\r\n        this.seasonWinter = [];\r\n        const winter = Data.seasonDescriptors.winter;\r\n        let availableWinterDescriptors = winter[this.humidity].concat(winter[this.temperature]);\r\n        for (let i = 0; i < 2; i++) {\r\n            const d = Util.randomValue(availableWinterDescriptors);\r\n            this.seasonWinter.push(d);\r\n            availableWinterDescriptors = Util.arrayRemove(availableWinterDescriptors, d);\r\n            //  If the word is longer than 5 letters, 100% chance to step out of the loop\r\n            //  Otherwise, 50% chance to step out of the loop\r\n            if (Util.rand() < 0.5 || d.length > 6)\r\n                break;\r\n        }\r\n        // Description of summer\r\n        this.seasonSummer = [];\r\n        const summer = Data.seasonDescriptors.summer;\r\n        let availableSummerDescriptors = summer[this.humidity].concat(summer[this.temperature]);\r\n        for (let i = 0; i < 2; i++) {\r\n            const d = Util.randomValue(availableSummerDescriptors);\r\n            if (this.seasonWinter.includes(d)) {\r\n                continue;\r\n            }\r\n            this.seasonSummer.push(d);\r\n            availableSummerDescriptors = Util.arrayRemove(availableSummerDescriptors, d);\r\n            if (Util.rand() < 0.5)\r\n                break;\r\n        }\r\n    }\r\n    determineBiomes() {\r\n        // mountain | boreal-forest | temperate-forest | grassland | tundra\r\n        let availableBiomes = Data.biomes.filter((str) => {\r\n            switch (this.humidity) {\r\n                case 'dry':\r\n                    // Dry? Remove boreal-forest and temperate-forest\r\n                    return !['boreal-forest', 'temperate-forest'].includes(str);\r\n                    break;\r\n                case 'wet':\r\n                    // Wet? Remove grassland and tundra\r\n                    return !['grassland', 'tundra'].includes(str);\r\n                    break;\r\n            }\r\n            return true;\r\n        });\r\n        availableBiomes = availableBiomes.filter((str) => {\r\n            switch (this.temperature) {\r\n                case 'warm':\r\n                    // Warm? Remove boreal-forest and tundra\r\n                    return !['boreal-forest', 'tundra'].includes(str);\r\n                    break;\r\n            }\r\n            return true;\r\n        });\r\n        // Add the primary biome\r\n        let b = Util.randomValue(availableBiomes);\r\n        // Reroll if mountains and larger than 1\r\n        if (b == 'mountains' && this.sizeIndex > 1)\r\n            b = Util.randomValue(availableBiomes);\r\n        availableBiomes = Util.arrayRemove(availableBiomes, b);\r\n        let availableSizeIndex = Data.sizes.indexOf(this.size) * 2;\r\n        let sizeIndex = Math.floor(Util.rand() * availableSizeIndex);\r\n        availableSizeIndex -= sizeIndex;\r\n        let primaryBiome = {\r\n            type: b,\r\n            size: Data.sizes[Math.max(1, sizeIndex)],\r\n            direction: Util.randomValue(Data.directions)\r\n        };\r\n        this.tags.push(primaryBiome.type);\r\n        this.biomes.push(primaryBiome);\r\n        if (Util.rand() < 0.6) {\r\n            // Choose a direction that isn't the same direction as the primary Biome's direction\r\n            // Also cannot be a combined direction like north-east or south-west, must be one of the four cardinal directions or 'middle'\r\n            let secondaryDirection;\r\n            do {\r\n                secondaryDirection = Util.randomValue(Data.directions);\r\n            } while (secondaryDirection.noun == primaryBiome.direction.noun ||\r\n                secondaryDirection.noun.includes('-'));\r\n            let secondaryBiome = {\r\n                type: Util.randomValue(availableBiomes),\r\n                size: Data.sizes[Math.floor(Util.rand() * availableSizeIndex)],\r\n                direction: secondaryDirection\r\n            };\r\n            // Add a second biome\r\n            this.biomes.push(secondaryBiome);\r\n            this.tags.push(secondaryBiome.type);\r\n        }\r\n    }\r\n    determineRivers() {\r\n        let pickRiverCount = { min: 0, max: 0 };\r\n        switch (this.humidity) {\r\n            case 'dry':\r\n                pickRiverCount.min = 0;\r\n                pickRiverCount.max = 2;\r\n                break;\r\n            case 'temperate':\r\n                pickRiverCount.min = 1;\r\n                pickRiverCount.max = 4;\r\n                break;\r\n            case 'wet':\r\n                pickRiverCount.min = 3;\r\n                pickRiverCount.max = 5;\r\n                break;\r\n        }\r\n        let riverCount = Math.floor(Util.rand(pickRiverCount.min, pickRiverCount.max));\r\n        // For small realms (less than 3 on the sizeIndex) there shouldn't be more than two rivers passing through\r\n        if (this.sizeIndex < 3) {\r\n            riverCount = Math.min(riverCount, 2);\r\n        }\r\n        // Add rivers\r\n        for (let i = 0; i < riverCount; i++) {\r\n            let flowsFrom;\r\n            let flowsFromMountains = false;\r\n            // If the realm contains a mountain biome, rivers should flow from it 60% of the time\r\n            const mountainBiome = this.biomes.find((b) => b.type == 'mountain');\r\n            if (mountainBiome && Util.rand() < 0.6) {\r\n                flowsFrom = mountainBiome.direction;\r\n                flowsFromMountains = true;\r\n            }\r\n            else {\r\n                flowsFrom = Util.randomValue(Data.directions);\r\n            }\r\n            let flowsTo;\r\n            let flowsToCoast = false;\r\n            // If the realm contains a coast, rivers should flow to it 60% of the time\r\n            // Rivers cannot travel from one direction to a direction that contains a matching word:\r\n            // north to west is OK, north to north-west is NOT, south to north-east is OK, south to south-east is NOT\r\n            if (this.coast && Util.rand() < 0.6) {\r\n                flowsTo = this.coastDirection;\r\n                flowsToCoast = true;\r\n            }\r\n            else {\r\n                do {\r\n                    flowsTo = Util.randomValue(Data.directions);\r\n                } while (flowsTo == flowsFrom ||\r\n                    flowsFrom.noun\r\n                        .split('-')\r\n                        .some((d) => flowsTo.noun.split('-').includes(d)));\r\n            }\r\n            let riverName = this.determineRiverName();\r\n            let tributaries = this.determineTributaries(riverName);\r\n            let river = {\r\n                name: riverName,\r\n                flowsTo: flowsTo,\r\n                flowsToCoast: flowsToCoast,\r\n                flowsFrom: flowsFrom,\r\n                flowsFromMountains: flowsFromMountains,\r\n                tributaries: tributaries,\r\n                prefix: null,\r\n                stem: null\r\n            };\r\n            this.rivers.push(river);\r\n        }\r\n        let arr = [];\r\n        for (let i = 0; i < 20; i++)\r\n            arr.push(Util.readWord(this.determineRiverName()));\r\n    }\r\n    determineTributaries(riverName) {\r\n        let tributaries = [];\r\n        const tributaryCount = Math.floor(Util.rand(2, 5));\r\n        for (let i = 0; i < tributaryCount; i++) {\r\n            let tributary = {\r\n                name: i == 0 && Util.rand() < 0.6 ? riverName : this.determineRiverName(),\r\n                flowsTo: Util.randomValue(Data.directions),\r\n                flowsToCoast: false,\r\n                flowsFrom: Util.randomValue(Data.directions),\r\n                flowsFromMountains: false,\r\n                tributaries: [],\r\n                prefix: null,\r\n                stem: null\r\n            };\r\n            // If the tributary name is the same as the stem, choose a tributary prefix\r\n            if (Util.readWord(riverName) == Util.readWord(tributary.name)) {\r\n                tributary.prefix = Util.randomValue(Data.tributaryNameParts.filter((namePart) => {\r\n                    return namePart.tags.includes('tributary-prefix');\r\n                }));\r\n            }\r\n            // The more tributaries there are the lower the chance is to add a new one\r\n            const max = 5;\r\n            const remaining = max - this.tributaries.length;\r\n            const chance = remaining * (1 / max) + 0.1; // Always give it +10% chance\r\n            console.log(Math.floor(chance * 100) +\r\n                '% chance due to ' +\r\n                remaining +\r\n                ' possible tributaries');\r\n            const n = Util.rand();\r\n            console.log('-- rolled: ' + Math.floor(n * 100) + ' ' + (n < chance));\r\n            if (n >= chance)\r\n                continue;\r\n            // Push to river tributary array (gets returned)\r\n            tributaries.push(tributary);\r\n            // Push to realm tributary array\r\n            this.tributaries.push(tributary);\r\n        }\r\n        return tributaries;\r\n    }\r\n    areNamePartTagsValid(namePart) {\r\n        let valid = true;\r\n        // Have at least one matching tag if tagRule is OR\r\n        if (namePart.tagRule == 'AND') {\r\n            valid = namePart.tags.every((tag) => this.tags.includes(tag));\r\n            if (!valid)\r\n                return valid;\r\n        }\r\n        // Have all matching tags if tagRule is AND\r\n        if (namePart.tagRule == 'OR') {\r\n            valid = namePart.tags.some((tag) => this.tags.includes(tag));\r\n            if (!valid)\r\n                return valid;\r\n        }\r\n        return valid;\r\n    }\r\n    determineRiverName() {\r\n        /**\r\n         * Determine root\r\n         */\r\n        let validRoots = Data.riverNameParts\r\n            .concat(Data.faunaNameParts)\r\n            .concat(Data.floraNameParts)\r\n            .filter((namePart) => {\r\n            // Root cannot be used by another river\r\n            // Have at least one point as a root name part\r\n            let valid = this.rivers.every((river) => river.name.root.name != namePart.name && namePart.asRoot > 0);\r\n            if (!valid)\r\n                return valid;\r\n            valid = this.areNamePartTagsValid(namePart);\r\n            if (!valid)\r\n                return valid;\r\n            return valid;\r\n        });\r\n        let root = Util.randomWeightedValue(validRoots, (item) => item.asRoot);\r\n        if (root.variations) {\r\n            root.variations.push(root.name);\r\n            root.name = Util.randomValue(root.variations);\r\n        }\r\n        /**\r\n         * Determine suffix\r\n         */\r\n        let validSuffixes = Data.riverNameParts.filter((namePart) => {\r\n            // Have at least one point as a suffix name part\r\n            // Have at least one matching tag\r\n            return (namePart.asSuffix > 0 &&\r\n                namePart.tags.some((tag) => this.tags.includes(tag)));\r\n        });\r\n        this.countRiverValidLoop = 0;\r\n        let riverName;\r\n        do {\r\n            let suffix = Util.randomWeightedValue(validSuffixes, (item) => item.asSuffix);\r\n            if (suffix.variations) {\r\n                suffix.variations.push(suffix.name);\r\n                suffix.name = Util.randomValue(suffix.variations);\r\n            }\r\n            riverName = { root: root, suffix: suffix };\r\n        } while (!this.isRiverNameValid(riverName));\r\n        return riverName;\r\n    }\r\n    isRiverNameValid(r) {\r\n        this.countRiverValidLoop++;\r\n        if (this.countRiverValidLoop > 200) {\r\n            // If you've tried 200 times to get a valid river name with the same root, abandon the root and start over\r\n            console.log(`No valid river name found with root '${r.root.name}', rerolling root...`);\r\n            return this.determineRiverName();\r\n        }\r\n        let valid = true;\r\n        // Can't have two vowels next to each other\r\n        if (Util.endsWithVowel(r.root.name) &&\r\n            Util.startsWithVowel(r.suffix.name)) {\r\n            valid = false;\r\n        }\r\n        // No two rivers or tributaries can have the same name\r\n        const tributaryNames = this.tributaries\r\n            .concat(this.rivers)\r\n            .map((river) => Util.readWord(river.name));\r\n        if (tributaryNames.includes(Util.readWord(r))) {\r\n            valid = false;\r\n        }\r\n        // Rivers' roots cannot end in their suffix (Hennen-en, Fei-ei, etc.)\r\n        if (r.root.name.indexOf(r.suffix.name) ==\r\n            r.root.name.length - r.suffix.name.length) {\r\n            valid = false;\r\n        }\r\n        return valid;\r\n    }\r\n    determineRealmName() {\r\n        /**\r\n         * Determine root\r\n         */\r\n        let validRoots = Data.placeNameParts\r\n            .concat(Data.rulersNameParts)\r\n            .concat(Data.faunaNameParts)\r\n            .concat(Data.floraNameParts)\r\n            .filter((namePart) => {\r\n            let valid = namePart.asRoot > 0 && this.areNamePartTagsValid(namePart);\r\n            if (!valid)\r\n                return valid;\r\n            return valid;\r\n        });\r\n        let root = Object.assign({}, Util.randomWeightedValue(validRoots, (item) => item.asRoot));\r\n        if (root.variations) {\r\n            root.variations.push(root.name);\r\n            root.name = Util.randomValue(root.variations);\r\n        }\r\n        /**\r\n         * Determine suffix\r\n         */\r\n        let validSuffixes = Data.placeNameParts.filter((namePart) => {\r\n            // Have at least one point as a suffix name part\r\n            // Have at least one matching tag\r\n            let valid = namePart.asSuffix > 0 && this.areNamePartTagsValid(namePart);\r\n            if (!valid)\r\n                return valid;\r\n            return valid;\r\n        });\r\n        do {\r\n            let suffix = Util.randomWeightedValue(validSuffixes, (item) => item.asSuffix);\r\n            if (suffix.variations) {\r\n                suffix.variations.push(suffix.name);\r\n                suffix.name = Util.randomValue(suffix.variations);\r\n            }\r\n            this.realmName = { root: root, suffix: suffix };\r\n        } while (!this.isRealmNameValid(this.realmName));\r\n    }\r\n    isRealmNameValid(word) {\r\n        let valid = true;\r\n        // Root and suffix can't be the same\r\n        if (word.root == word.suffix)\r\n            return false;\r\n        return valid;\r\n    }\r\n    determineCities() { }\r\n}\r\n","import { Data } from './Data';\r\nexport default class Util {\r\n    static download(name, text) {\r\n        var element = document.createElement('a');\r\n        element.setAttribute('href', 'data:text/plain;charset=utf-8,' + encodeURIComponent(text));\r\n        element.setAttribute('download', name);\r\n        element.style.display = 'none';\r\n        document.body.appendChild(element);\r\n        element.click();\r\n        document.body.removeChild(element);\r\n    }\r\n    static toggleDarkMode() {\r\n        Util.isDarkMode = !Util.isDarkMode;\r\n        localStorage.setItem('darkMode', JSON.stringify(Util.isDarkMode));\r\n        Util.isDarkMode ? Util.applyDarkMode() : Util.applyLightMode();\r\n    }\r\n    static applyDarkMode() {\r\n        console.log('Apply dark mode');\r\n        const mode = [\r\n            { id: '--dark-text', value: '#f8f8f8' },\r\n            { id: '--dark-text-muted', value: 'rgba(248, 248, 248, 0.6)' },\r\n            { id: '--dark-text-very-muted', value: 'rgba(248, 248, 248, 0.1)' },\r\n            { id: '--dark-text-hidden', value: 'rgba(248, 248, 248, 0)' },\r\n            { id: '--light-text', value: '#444444' },\r\n            { id: '--light-text-muted', value: 'rgba(68, 68, 68, 0.6)' },\r\n            { id: '--light-text-very-muted', value: 'rgba(68, 68, 68, 0.1)' },\r\n            { id: '--light-text-hidden', value: 'rgba(68, 68, 68, 0)' },\r\n            { id: '--dark-background', value: '#f8f8f8' },\r\n            { id: '--dark-background-alt', value: 'rgba(248, 248, 248, 0.95)' },\r\n            { id: '--light-background', value: '#444444' },\r\n            { id: '--light-background-alt', value: 'rgba(68, 68, 68, 0.95)' }\r\n        ];\r\n        var root = document.querySelector(':root');\r\n        mode.forEach((m) => {\r\n            root.style.setProperty(m.id, m.value);\r\n        });\r\n    }\r\n    static applyLightMode() {\r\n        console.log('Apply light mode');\r\n        const mode = [\r\n            { id: '--dark-text', value: '#444444' },\r\n            { id: '--dark-text-muted', value: 'rgba(68, 68, 68, 0.6)' },\r\n            { id: '--dark-text-very-muted', value: 'rgba(68, 68, 68, 0.1)' },\r\n            { id: '--dark-text-hidden', value: 'rgba(68, 68, 68, 0)' },\r\n            { id: '--light-text', value: '#f8f8f8' },\r\n            { id: '--light-text-muted', value: 'rgba(248, 248, 248, 0.6)' },\r\n            { id: '--light-text-very-muted', value: 'rgba(248, 248, 248, 0.1)' },\r\n            { id: '--light-text-hidden', value: 'rgba(248, 248, 248, 0)' },\r\n            { id: '--dark-background', value: '#444444' },\r\n            { id: '--dark-background-alt', value: 'rgba(68, 68, 68, 0.95)' },\r\n            { id: '--light-background', value: '#f8f8f8' },\r\n            { id: '--light-background-alt', value: 'rgba(248, 248, 248, 0.95)' }\r\n        ];\r\n        var root = document.querySelector(':root');\r\n        mode.forEach((m) => {\r\n            root.style.setProperty(m.id, m.value);\r\n        });\r\n    }\r\n    static generateSeed() {\r\n        let arr = [];\r\n        for (let i = 0; i < 3; i++) {\r\n            arr.push(Util.randomValue(Data.words, false));\r\n        }\r\n        Util.seed = arr.join('-');\r\n        Util.seedRandomNumberGenerator();\r\n    }\r\n    static seedRandomNumberGenerator() {\r\n        let h = 1779033703 ^ Util.seed.length;\r\n        for (var i = 0; i < Util.seed.length; i++) {\r\n            h = Math.imul(h ^ Util.seed.charCodeAt(i), 3432918353);\r\n            h = (h << 13) | (h >>> 19);\r\n        }\r\n        Util.m_w = (123456789 + h) & Util.mask;\r\n        Util.m_z = (987654321 - h) & Util.mask;\r\n    }\r\n    static rand(min = 0, max = 1) {\r\n        Util.m_z = (36969 * (Util.m_z & 65535) + (Util.m_z >> 16)) & Util.mask;\r\n        Util.m_w = (18000 * (Util.m_w & 65535) + (Util.m_w >> 16)) & Util.mask;\r\n        let result = ((Util.m_z << 16) + (Util.m_w & 65535)) >>> 0;\r\n        result /= 4294967296;\r\n        return result * (max - min) + min;\r\n    }\r\n    static arrayRemove(arr, elementToRemove) {\r\n        return arr.filter(function (element) {\r\n            return element != elementToRemove;\r\n        });\r\n    }\r\n    // Returns a random value from an array\r\n    static randomValue(u, seeded = true) {\r\n        return seeded\r\n            ? u[Math.floor(Util.rand() * u.length)]\r\n            : u[Math.floor(Math.random() * u.length)];\r\n    }\r\n    // Returns 'a' or 'an' if str's first char is a consonant or a vowel\r\n    static aOrAn(str) {\r\n        return Util.startsWithVowel(str) ? 'an' : 'a';\r\n    }\r\n    // Returns true if the string ends with a given str\r\n    static endsWith(str, endingStr) {\r\n        const regex = new RegExp('.*' + endingStr + '$');\r\n        return regex.test(str);\r\n    }\r\n    // Returns true if the string starts with a vowel\r\n    static startsWithVowel(str) {\r\n        const regex = new RegExp('^[aeiou].*', 'i');\r\n        return regex.test(str);\r\n    }\r\n    // Returns true if the string starts with a vowel\r\n    static endsWithVowel(str) {\r\n        const regex = new RegExp('.*[aeiou]$', 'i');\r\n        return regex.test(str);\r\n    }\r\n    // Returns a string joining an array of at least two entries\r\n    // with commas and the word 'and' between the last two entries\r\n    static joinArrayWithAnd(arr) {\r\n        const last = arr.pop();\r\n        if (arr.length == 1) {\r\n            return arr[0] + ' and ' + last;\r\n        }\r\n        let str = arr.join(', ');\r\n        str += ', and ' + last;\r\n        return str;\r\n    }\r\n    // Returns an item from an array\r\n    // The weight value is determined using the accessor function\r\n    // randomWeightedValue<NamePart>(nameParts, item => item.asRoot)\r\n    static randomWeightedValue(arr, accessor, log = false) {\r\n        if (log)\r\n            console.log(arr);\r\n        // Get the max weight\r\n        const max = arr.reduce((total, item) => {\r\n            return total + accessor(item);\r\n        }, 0);\r\n        // Calculate a random number on the scale of max\r\n        let weight = Util.rand() * max;\r\n        // For each item in the array, decrement max by that item's weight\r\n        let result;\r\n        arr.some((item) => {\r\n            weight -= accessor(item);\r\n            result = item;\r\n            return weight < 0;\r\n        });\r\n        return result;\r\n    }\r\n    // Tweet a realm\r\n    static shareByTweet(realm) {\r\n        let tweet = `Explore ${Util.capitalize(Util.readWord(realm.realmName))}, a ${realm.size} ${realm.parentEntityAdj} ${realm.governmentRank}.`;\r\n        window.open('https://twitter.com/intent/tweet?url=' +\r\n            window.location.href +\r\n            '&text=' +\r\n            tweet, '_blank');\r\n    }\r\n    // Capitalize first letter\r\n    static capitalize(str) {\r\n        return str.charAt(0).toUpperCase() + str.substring(1);\r\n    }\r\n    // Combines word parts into a string\r\n    static readWord(word) {\r\n        return word.root.name + word.suffix.name;\r\n    }\r\n    // Returns any number lower than 20 as a word ('one', 'two', ... 'nineteen')\r\n    static wordFromNumber(n) {\r\n        const words = [\r\n            'zero',\r\n            'one',\r\n            'two',\r\n            'three',\r\n            'four',\r\n            'five',\r\n            'six',\r\n            'seven',\r\n            'eight',\r\n            'nine',\r\n            'ten',\r\n            'eleven',\r\n            'twelve',\r\n            'thirteen',\r\n            'fourteen',\r\n            'fifteen',\r\n            'sixteen',\r\n            'seventeen',\r\n            'eighteen',\r\n            'nineteen'\r\n        ];\r\n        return n < words.length ? words[n] : n.toString();\r\n    }\r\n}\r\nUtil.isDarkMode = false;\r\nUtil.m_w = 123456789;\r\nUtil.m_z = 987654321;\r\nUtil.mask = 4294967295;\r\n","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","import Util from './Util';\r\nimport { Data } from './Data';\r\nimport { Realm } from './Realm';\r\n/**\r\n * Hint: Use 'npm run build' from console to compile + watch the TS code on save\r\n */\r\n// Initial local preferences\r\nconst darkModeAtStart = localStorage.getItem('darkMode');\r\nconst isDarkModeAtStart = darkModeAtStart != null && darkModeAtStart == 'true';\r\nisDarkModeAtStart ? Util.toggleDarkMode() : null;\r\n// Handle dark mode button\r\nconst btnToggleDarkMode = document.getElementById('btnToggleDarkMode');\r\nbtnToggleDarkMode.addEventListener('click', () => {\r\n    Util.toggleDarkMode();\r\n    // Add the background-transition class to the body if it's not already there\r\n    const body = document.querySelector('body');\r\n    if (!body.classList.contains('background-transition')) {\r\n        body.classList.add('background-transition');\r\n    }\r\n});\r\n/**\r\n * Favorites\r\n */\r\nif (!localStorage.getItem('favorites'))\r\n    localStorage.setItem('favorites', JSON.stringify([]));\r\nlet favorites = JSON.parse(localStorage.getItem('favorites'));\r\n// Update favorites\r\nconst favoritesEl = document.getElementById('favorites');\r\nfavoritesEl.addEventListener('click', (event) => {\r\n    const key = event.target.getAttribute('key');\r\n    if (key) {\r\n        favorites = favorites.filter((f) => f.id != key);\r\n        event.preventDefault();\r\n        localStorage.setItem('favorites', JSON.stringify(favorites));\r\n        updateFavorites();\r\n    }\r\n});\r\nconst btnFavorite = document.getElementById('btnFavorite');\r\nconst btnFavoriteIcon = document.querySelector('#btnFavorite i');\r\nconst btnFavoriteText = document.querySelector('#btnFavorite span');\r\nfunction updateFavorites() {\r\n    // Update the button\r\n    console.log('updating favorites');\r\n    btnFavoriteIcon.classList.remove('fa-solid', 'fa-regular', 'selected');\r\n    const isFavorite = favorites.some((f) => f.id == Util.seed);\r\n    btnFavoriteIcon.classList.add(isFavorite ? 'fa-solid' : 'fa-regular');\r\n    btnFavoriteText.innerHTML = isFavorite\r\n        ? 'This is one of your favorites'\r\n        : 'Add this Realm to your favorites';\r\n    favoritesEl.innerHTML = '';\r\n    favorites.forEach((f) => {\r\n        let url = window.location.href;\r\n        url = url.substring(0, url.indexOf('?')) + '?' + f.id;\r\n        favoritesEl.innerHTML += `\r\n    <li class=\"favorite-badge\">\r\n      <a href=\"${url}\" target=\"_blank\" class=\"btn btn--icon capitalized\">${f.name}</a>\r\n      <a class=\"btn btn--icon delete-favorite\">\r\n        <i class=\"fa-solid fa-xmark\" key=\"${f.id}\"></i>\r\n      </a>\r\n    </li>`;\r\n    });\r\n}\r\nbtnFavorite.addEventListener('click', () => {\r\n    const f = {\r\n        id: Util.seed,\r\n        name: Util.readWord(realm.realmName)\r\n    };\r\n    if (!favorites.some((v) => f.id == v.id)) {\r\n        favorites.push(f);\r\n    }\r\n    else {\r\n        favorites = favorites.filter((v) => v.id != f.id);\r\n    }\r\n    localStorage.setItem('favorites', JSON.stringify(favorites));\r\n    updateFavorites();\r\n});\r\n// Handle start button\r\nconst btnStart = document.getElementById('btnStart');\r\nbtnStart.addEventListener('click', generateSeedAndStart);\r\n// Handle copy button\r\nconst btnCopyLink = document.getElementById('btnCopyLink');\r\nbtnCopyLink.addEventListener('click', () => {\r\n    navigator.clipboard.writeText(window.location.href);\r\n    // Play copied animation\r\n    btnCopyLink.innerHTML = `<i class=\"fa-solid fa-check\" style=\"color: #17b664\"></i>Copied!`;\r\n    btnCopyLink.setAttribute('disabled', 'true');\r\n    document.getElementById('labelShare').style.opacity = '0';\r\n    setTimeout(() => {\r\n        // Play copied animation\r\n        btnCopyLink.innerHTML = `<i class=\"fa-solid fa-copy\"></i>Copy Link`;\r\n        btnCopyLink.removeAttribute('disabled');\r\n    }, 2000);\r\n});\r\nbtnCopyLink.addEventListener('mouseover', () => {\r\n    if (btnCopyLink.hasAttribute('disabled'))\r\n        return;\r\n    document.getElementById('labelShare').innerHTML = window.location.href;\r\n    document.getElementById('labelShare').style.top = '0';\r\n    document.getElementById('labelShare').style.opacity = '1';\r\n});\r\nbtnCopyLink.addEventListener('mouseout', fadeOutShareLabel);\r\n// Handle tweet button\r\nconst btnShareTwitter = document.getElementById('btnShareTwitter');\r\nbtnShareTwitter.addEventListener('click', () => {\r\n    Util.shareByTweet(realm);\r\n});\r\nbtnShareTwitter.addEventListener('mouseover', () => {\r\n    if (btnShareTwitter.hasAttribute('disabled'))\r\n        return;\r\n    document.getElementById('labelShare').innerHTML =\r\n        'Share this Realm on Twitter';\r\n    document.getElementById('labelShare').style.top = '0';\r\n    document.getElementById('labelShare').style.opacity = '1';\r\n});\r\nbtnShareTwitter.addEventListener('mouseout', fadeOutShareLabel);\r\n// Handle JSON button\r\nconst btnJson = document.getElementById('btnJson');\r\nbtnJson.addEventListener('click', () => {\r\n    window.open(window.location.href + '&json', '_self');\r\n});\r\nbtnJson.addEventListener('mouseover', () => {\r\n    if (btnJson.hasAttribute('disabled'))\r\n        return;\r\n    document.getElementById('labelShare').innerHTML =\r\n        \"View this Realm's JSON data\";\r\n    document.getElementById('labelShare').style.top = '0';\r\n    document.getElementById('labelShare').style.opacity = '1';\r\n});\r\nbtnJson.addEventListener('mouseout', fadeOutShareLabel);\r\nfunction fadeInShareLabel() {\r\n    document.getElementById('labelShare').style.top = '0';\r\n    document.getElementById('labelShare').style.opacity = '1';\r\n}\r\nfunction fadeOutShareLabel() {\r\n    document.getElementById('labelShare').style.top = '0.4rem';\r\n    document.getElementById('labelShare').style.opacity = '0';\r\n}\r\nfunction handleJsonButtons() {\r\n    // Handle the Realm from JSON button\r\n    const btnToRealm = document.getElementById('btnToRealm');\r\n    btnToRealm.addEventListener('click', () => {\r\n        const arr = window.location.href.match(/(.+\\?[a-z0-9,-]+).*\\&/);\r\n        if (arr && arr.length > 1) {\r\n            window.open(arr[1], '_self');\r\n        }\r\n    });\r\n    btnToRealm.addEventListener('mouseover', () => {\r\n        if (btnJson.hasAttribute('disabled'))\r\n            return;\r\n        document.getElementById('labelJson').innerHTML = 'View the Realm page';\r\n        fadeInJsonLabel();\r\n    });\r\n    btnToRealm.addEventListener('mouseout', fadeOutJsonLabel);\r\n    // Handle the Copy JSON button\r\n    const btnCopyJson = document.getElementById('btnCopyJson');\r\n    btnCopyJson.addEventListener('click', () => {\r\n        // Play copied animation\r\n        btnCopyJson.innerHTML = `<i class=\"fa-solid fa-check\" style=\"color: orangered\"></i>Copied!`;\r\n        btnCopyJson.setAttribute('disabled', 'true');\r\n        document.getElementById('labelJson').style.opacity = '0';\r\n        navigator.clipboard.writeText(JSON.stringify(realm, null, '  '));\r\n        setTimeout(() => {\r\n            // Play copied animation\r\n            btnCopyJson.innerHTML = `<i class=\"fa-solid fa-copy\"></i>Copy JSON`;\r\n            btnCopyJson.removeAttribute('disabled');\r\n        }, 2000);\r\n    });\r\n    btnCopyJson.addEventListener('mouseover', () => {\r\n        if (btnCopyJson.hasAttribute('disabled'))\r\n            return;\r\n        document.getElementById('labelJson').innerHTML =\r\n            'Copy this JSON to your clipboard';\r\n        fadeInJsonLabel();\r\n    });\r\n    btnCopyJson.addEventListener('mouseout', fadeOutJsonLabel);\r\n    // Handle the Download JSON button\r\n    const btnDownloadJson = document.getElementById('btnDownloadJson');\r\n    btnDownloadJson.addEventListener('click', () => {\r\n        var blob = new Blob([JSON.stringify(realm, null, '')], {\r\n            type: 'text/plain;charset=utf-8'\r\n        });\r\n        Util.download(Util.readWord(realm.realmName) + '.json', JSON.stringify(realm, null, '  '));\r\n    });\r\n    btnDownloadJson.addEventListener('mouseover', () => {\r\n        if (btnDownloadJson.hasAttribute('disabled'))\r\n            return;\r\n        document.getElementById('labelJson').innerHTML =\r\n            'Download this JSON to a .json file';\r\n        fadeInJsonLabel();\r\n    });\r\n    btnDownloadJson.addEventListener('mouseout', fadeOutJsonLabel);\r\n    function fadeInJsonLabel() {\r\n        document.getElementById('labelJson').style.top = '0';\r\n        document.getElementById('labelJson').style.opacity = '1';\r\n    }\r\n    function fadeOutJsonLabel() {\r\n        document.getElementById('labelJson').style.top = '0.4rem';\r\n        document.getElementById('labelJson').style.opacity = '0';\r\n    }\r\n}\r\n// Load data\r\nData.setup(() => {\r\n    // Does the url contain a seed (query)?\r\n    // www.google.com?foo\r\n    //    -> foo\r\n    // www.google.com?bar#\r\n    //    -> bar\r\n    const url = window.location.href;\r\n    const arr = url.match(/\\?([a-z0-9,-]+)/);\r\n    if (arr && arr.length > 1) {\r\n        Util.seed = arr[1];\r\n        start();\r\n    }\r\n    else {\r\n        generateSeedAndStart();\r\n    }\r\n});\r\n// Initialize variables\r\nlet realm;\r\nfunction generateSeedAndStart() {\r\n    Util.generateSeed();\r\n    let url = window.location.href;\r\n    url = url.substring(0, url.indexOf('?'));\r\n    if (window.location.href)\r\n        window.location.replace(url + '?' + Util.seed);\r\n}\r\n// Start the generation process\r\nfunction start() {\r\n    Util.seedRandomNumberGenerator();\r\n    realm = new Realm();\r\n    updateFavorites();\r\n    // Is it json?\r\n    const arr = window.location.href.match(/\\?[a-z0-9,-]+.*\\&(json)/);\r\n    const jsonContainer = document.querySelector('.container--json');\r\n    if (arr && arr.length > 1) {\r\n        // Show JSON\r\n        jsonContainer.classList.remove('hidden');\r\n        const jsonContent = document.querySelector('.json-content');\r\n        jsonContent.innerHTML =\r\n            '<pre class=\"json-format\">' +\r\n                JSON.stringify(realm, null, '  ') +\r\n                '</pre>';\r\n        handleJsonButtons();\r\n        // Hide content\r\n        const content = document.querySelector('div.content');\r\n        content.classList.add('hidden');\r\n        applyText('name', Util.readWord(realm.realmName));\r\n    }\r\n    else {\r\n        // Don't show JSON\r\n        jsonContainer.innerHTML = '';\r\n        updateView();\r\n    }\r\n    // Delay intro animations\r\n    const sectionEls = document.querySelectorAll('.container');\r\n    sectionEls.forEach((node, index) => {\r\n        const el = node;\r\n        setTimeout(() => {\r\n            el.classList.add('fade-in');\r\n        }, 250 * index);\r\n    });\r\n    // testSnippets();\r\n}\r\nfunction testSnippets() {\r\n    // Test Util.endsWith function\r\n    for (let i = 0; i < 10; i++) {\r\n        let str = Util.randomValue(Data.words);\r\n        console.log(`${str} ends with t? ${Util.endsWith(str, 't')}`);\r\n    }\r\n}\r\nfunction updateView() {\r\n    // Choose a photo for the hero\r\n    const heroEl = document.getElementById('hero');\r\n    heroEl.setAttribute('style', `background-image: linear-gradient(rgba(0, 0, 0, 0.7), rgba(0, 0, 0, 0.7)), url(${determineHeroImageUrl()})`);\r\n    // Blurbs\r\n    applyBiomesBlurb();\r\n    applyRiversBlurb();\r\n    applyCoatBlurb();\r\n    toggleVisibility('sigil-present-on-heraldry', realm.sigilPresentOnHeraldry);\r\n    toggleVisibility('on-the-coast', realm.coast);\r\n    // Words\r\n    applyText('name', Util.readWord(realm.realmName));\r\n    applyText('government-rank', realm.governmentRank);\r\n    applyText('parent-entity', realm.parentEntityName);\r\n    applyText('parent-entity-adj', realm.parentEntityAdj);\r\n    applyText('direction-within-parent-entity', realm.directionWithinParentEntity.noun);\r\n    applyText('direction-adj-within-parent-entity', realm.directionWithinParentEntity.adj);\r\n    applyText('coast-direction', realm.coastDirection.adj);\r\n    applyText('capital-city', realm.capitalCityName);\r\n    applyText('sigil-name', realm.sigilName);\r\n    applyText('sigil-meaning', realm.sigilMeaning);\r\n    applyText('size', realm.size);\r\n    applyText('temperature', realm.temperature);\r\n    applyText('humidity', realm.humidity);\r\n    applyText('season-summer', realm.seasonSummer.join(', '));\r\n    applyText('season-winter', realm.seasonWinter.join(', '));\r\n    applyText('tincture-primary', realm.coat.tinctures[0].name, ' <span class=\"tincture tincture-primary-color\"></span>');\r\n    applyText('tincture-secondary', realm.coat.tinctures[1].name, ' <span class=\"tincture tincture-secondary-color\"></span>');\r\n    if (realm.coat.charge) {\r\n        applyText('charge-name', realm.coat.charge.name);\r\n        applyText('tincture-charge', realm.coat.chargeTincture.name, ' <span class=\"tincture tincture-charge-color\"></span>');\r\n    }\r\n    applyTinctureColors();\r\n    applyIcon('sigil', realm.sigilIcon);\r\n    // Utility\r\n    replaceNumbers();\r\n}\r\nfunction determineHeroImageUrl() {\r\n    // Todo use realm information to determine the image\r\n    const validImages = Data.heroImages\r\n        .filter((u) => {\r\n        return u.tags.some((tag) => realm.tags.includes(tag));\r\n    })\r\n        .map((j) => {\r\n        return j.url;\r\n    });\r\n    // console.log(validImages);\r\n    const image = Util.randomValue(validImages);\r\n    return image;\r\n}\r\nfunction applyText(query, text, app = '') {\r\n    const els = document.querySelectorAll('span.' + query);\r\n    els.forEach((node) => {\r\n        const el = node;\r\n        if (el.classList.contains('prepend-article')) {\r\n            el.textContent = Util.aOrAn(text) + ' ' + text + app;\r\n        }\r\n        else {\r\n            el.innerHTML = text + app;\r\n        }\r\n    });\r\n}\r\nfunction toggleVisibility(query, visible) {\r\n    const els = document.querySelectorAll('span.' + query);\r\n    els.forEach((node) => {\r\n        const el = node;\r\n        if (visible) {\r\n            el.classList.remove('hidden');\r\n        }\r\n        else {\r\n            el.classList.add('hidden');\r\n        }\r\n    });\r\n}\r\nfunction applyIcon(query, icon) {\r\n    const els = document.querySelectorAll('i.' + query);\r\n    els.forEach((node) => {\r\n        const el = node;\r\n        // Remove the previous icon\r\n        el.classList.forEach((className) => {\r\n            let text = '';\r\n            if (className.includes('fa-') && className !== 'fa-2x') {\r\n                el.classList.remove(className);\r\n            }\r\n        });\r\n        el.classList.add('fa-' + icon);\r\n    });\r\n}\r\nfunction applyBiomesBlurb() {\r\n    let text = '';\r\n    if (realm.biomes.length == 1) {\r\n        let b = realm.biomes[0];\r\n        text = `Much of <span class=\"name\"></span> is occupied by a ${b.type} ecoregion.`;\r\n    }\r\n    else if (realm.biomes.length == 2) {\r\n        let b1 = realm.biomes[0];\r\n        let b2 = realm.biomes[1];\r\n        text = `The ecoregions of <span class=\"name\"></span> consist mostly of ${b1.type} with a ${b2.size} ${b2.type} region in the ${b2.direction.noun}.`;\r\n    }\r\n    const el = document.querySelector('.biomes-blurb');\r\n    el.innerHTML = text;\r\n}\r\nfunction applyRiversBlurb() {\r\n    let text = '';\r\n    if (realm.rivers.length == 0) {\r\n        // No rivers\r\n        text = `No notable rivers pass through <span class=\"name\"></span>.`;\r\n    }\r\n    else if (realm.rivers.length == 1) {\r\n        // One river\r\n        let r = realm.rivers[0];\r\n        text = `The main river that flows through <span class=\"name\"></span> is the <span class=\"capitalized\">${Util.readWord(r.name)}</span>. `;\r\n        // Flows from...\r\n        text += `The <span class=\"capitalized\">${Util.readWord(r.name)}</span> `;\r\n        if (r.flowsFromMountains) {\r\n            text += `begins in the ${r.flowsFrom.adj} mountains `;\r\n        }\r\n        else {\r\n            text += `enters <span class=\"name\"></span> in the ${r.flowsFrom.noun} `;\r\n        }\r\n        // Flows to...\r\n        if (r.flowsToCoast) {\r\n            text += `and forms an estuary on the ${r.flowsTo.adj} coast. `;\r\n        }\r\n        else {\r\n            text += `and flows toward the ${r.flowsTo.noun}. `;\r\n        }\r\n    }\r\n    else {\r\n        // More than one river\r\n        text = `<span class=\"word-number capitalized\">${realm.rivers.length}</span> rivers pass through <span class=\"name\"></span>: ${Util.joinArrayWithAnd(realm.rivers.map((river) => {\r\n            return `the <span class=\"capitalized\">${Util.readWord(river.name)}</span>`;\r\n        }))}. `;\r\n    }\r\n    if (realm.tributaries.length > 0) {\r\n        text +=\r\n            'Notable tributaries include the rivers ' +\r\n                Util.joinArrayWithAnd(realm.tributaries.map((tributary) => {\r\n                    let prefix = tributary.prefix != null ? tributary.prefix.name + ' ' : '';\r\n                    return `<span class=\"capitalized\">${prefix}</span><span class=\"capitalized\">${Util.readWord(tributary.name)}</span>`;\r\n                })) +\r\n                '.';\r\n    }\r\n    const el = document.querySelector('.rivers-blurb');\r\n    el.innerHTML = text;\r\n}\r\nfunction applyCoatBlurb() {\r\n    let text = '';\r\n    text = `<span>The design of <span class=\"name\"></span>'s coat of arms resembles `;\r\n    text += realm.coat.ordinary.description + `</span>.`;\r\n    if (realm.coat.chargeLayout) {\r\n        text += ' ' + realm.coat.chargeLayout.description;\r\n    }\r\n    const el = document.querySelector('.coat-of-arms-blurb');\r\n    el.innerHTML = text;\r\n}\r\nfunction applyTinctureColors() {\r\n    const el1 = document.querySelector('.tincture-primary-color');\r\n    if (el1)\r\n        el1.style.backgroundColor = realm.coat.tinctures[0].color;\r\n    const el2 = document.querySelector('.tincture-secondary-color');\r\n    if (el2)\r\n        el2.style.backgroundColor = realm.coat.tinctures[1].color;\r\n    if (realm.coat.chargeTincture) {\r\n        const el3 = document.querySelector('.tincture-charge-color');\r\n        if (el3)\r\n            el3.style.backgroundColor = realm.coat.chargeTincture.color;\r\n    }\r\n}\r\nfunction replaceNumbers() {\r\n    const els = document.querySelectorAll('.word-number');\r\n    els.forEach((node) => {\r\n        const el = node;\r\n        el.textContent = Util.wordFromNumber(Number.parseInt(el.textContent ? el.textContent : '0'));\r\n    });\r\n}\r\n"],"names":[],"sourceRoot":""}